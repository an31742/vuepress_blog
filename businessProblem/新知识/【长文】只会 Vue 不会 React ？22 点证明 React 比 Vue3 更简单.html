<!doctype html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.14" />
    <meta name="theme" content="VuePress Theme Hope 2.0.0-rc.50" />
    <style>
      html {
        background: var(--bg-color, #fff);
      }

      html[data-theme="dark"] {
        background: var(--bg-color, #1d1e1f);
      }

      body {
        background: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.documentElement.setAttribute("data-theme", "dark");
      }
    </script>
    <meta property="og:url" content="https://vuepress-theme-hope-docs-demo.netlify.app/businessProblem/%E6%96%B0%E7%9F%A5%E8%AF%86/%E3%80%90%E9%95%BF%E6%96%87%E3%80%91%E5%8F%AA%E4%BC%9A%20Vue%20%E4%B8%8D%E4%BC%9A%20React%20%EF%BC%9F22%20%E7%82%B9%E8%AF%81%E6%98%8E%20React%20%E6%AF%94%20Vue3%20%E6%9B%B4%E7%AE%80%E5%8D%95.html"><meta property="og:site_name" content="前端知识随笔"><meta property="og:title" content="简单入门react"><meta property="og:description" content="转载自https://juejin.cn/post/7344536653463207973 真看完本文，将打破 “React 难” 的认知。你只要会 JS 就会 React 开始 大家好，我是 双越老师~ 现在还有大量的前端同学只会 Vue 不会 React，想学吧也不知道从何入手，也感觉自己没时间。 同时，现在已经有大量的公司招聘要求 React 技..."><meta property="og:type" content="article"><meta property="og:image" content="https://cdn.nlark.com/yuque/0/2024/webp/28199172/1719452106891-68bcc31e-931d-4323-940b-97db42ccdcd8.webp#averageHue=%23c0aea9&clientId=u0044065a-f65d-4&from=paste&id=u3d37f71d&originHeight=646&originWidth=2020&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=uac51fa69-dacb-4254-9112-6efc7cae44f&title="><meta property="og:locale" content="zh-CN"><meta property="og:updated_time" content="2024-06-28T01:37:54.000Z"><meta property="article:author" content="小安"><meta property="article:modified_time" content="2024-06-28T01:37:54.000Z"><script type="application/ld+json">{"@context":"https://schema.org","@type":"Article","headline":"简单入门react","image":["https://cdn.nlark.com/yuque/0/2024/webp/28199172/1719452106891-68bcc31e-931d-4323-940b-97db42ccdcd8.webp#averageHue=%23c0aea9&clientId=u0044065a-f65d-4&from=paste&id=u3d37f71d&originHeight=646&originWidth=2020&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=uac51fa69-dacb-4254-9112-6efc7cae44f&title=","https://cdn.nlark.com/yuque/0/2024/webp/28199172/1719452106968-9b9054a6-621a-486f-899f-615b7d5a2445.webp#averageHue=%23f6f6f6&clientId=u0044065a-f65d-4&from=paste&id=ud2e6896e&originHeight=490&originWidth=1642&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u337da7e3-2874-4dd4-93ea-bdab7a8c5d9&title=","https://cdn.nlark.com/yuque/0/2024/webp/28199172/1719452106980-eef6d0e3-4a82-487a-ba60-9d3c126e7a26.webp#averageHue=%2323201f&clientId=u0044065a-f65d-4&from=paste&id=u3b3de8bc&originHeight=666&originWidth=1742&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u971794fd-622a-4976-a810-deaa1ab3cc5&title=","https://cdn.nlark.com/yuque/0/2024/webp/28199172/1719452106987-33962143-f70e-4c78-8a8c-a17b9ba897c2.webp#averageHue=%2322201f&clientId=u0044065a-f65d-4&from=paste&id=uc4fd173c&originHeight=640&originWidth=1772&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u6e87049e-9c42-482b-ab10-264d53a8b5e&title=","https://cdn.nlark.com/yuque/0/2024/webp/28199172/1719452106975-4b23a21e-bd0d-49bb-878f-b5a331767b30.webp#averageHue=%23272221&clientId=u0044065a-f65d-4&from=paste&id=uaa5c05bd&originHeight=392&originWidth=1586&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u09f06e8b-e916-48a6-a668-04e3585d96c&title=","https://cdn.nlark.com/yuque/0/2024/webp/28199172/1719452107355-6bbc897e-cafb-4c79-83e9-d1578944ad8e.webp#averageHue=%23653b2d&clientId=u0044065a-f65d-4&from=paste&id=ua09df895&originHeight=264&originWidth=1662&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=ud7dd87d6-3931-45d1-8b6a-fdf099385e8&title=","https://cdn.nlark.com/yuque/0/2024/webp/28199172/1719452107454-e71598b2-9147-4549-946b-36c541b96685.webp#averageHue=%23f6f6f6&clientId=u0044065a-f65d-4&from=paste&id=udcb867c5&originHeight=490&originWidth=1642&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u1903cf04-f8ff-451c-9594-8f586601b9e&title="],"dateModified":"2024-06-28T01:37:54.000Z","author":[{"@type":"Person","name":"小安","url":"https://github.com/an31742"}]}</script><title>简单入门react | 前端知识随笔</title><meta name="description" content="转载自https://juejin.cn/post/7344536653463207973 真看完本文，将打破 “React 难” 的认知。你只要会 JS 就会 React 开始 大家好，我是 双越老师~ 现在还有大量的前端同学只会 Vue 不会 React，想学吧也不知道从何入手，也感觉自己没时间。 同时，现在已经有大量的公司招聘要求 React 技...">
    <link rel="preload" href="/assets/style-C6G1EAyw.css" as="style"><link rel="stylesheet" href="/assets/style-C6G1EAyw.css">
    <link rel="modulepreload" href="/assets/app-HeVUa9bp.js"><link rel="modulepreload" href="/assets/【长文】只会 Vue 不会 React ？22 点证明 React 比 Vue3 更简单.html-hRZUAV8b.js"><link rel="modulepreload" href="/assets/plugin-vue_export-helper-DlAUqK2U.js">
    <link rel="prefetch" href="/assets/index.html-BxmH1UMe.js" as="script"><link rel="prefetch" href="/assets/portfolio.html-KrP7lqRJ.js" as="script"><link rel="prefetch" href="/assets/index.html-wQ0EJ8JJ.js" as="script"><link rel="prefetch" href="/assets/git.html-C19X2Nn7.js" as="script"><link rel="prefetch" href="/assets/node.html-UypIwN9-.js" as="script"><link rel="prefetch" href="/assets/typeScript.html-COdaGKr9.js" as="script"><link rel="prefetch" href="/assets/设计模式.html-Bh4qXctC.js" as="script"><link rel="prefetch" href="/assets/跨域.html-BQVGGhZ0.js" as="script"><link rel="prefetch" href="/assets/index.html-DIkRntRN.js" as="script"><link rel="prefetch" href="/assets/disable.html-BppfLHIK.js" as="script"><link rel="prefetch" href="/assets/encrypt.html-DWktoCQq.js" as="script"><link rel="prefetch" href="/assets/layout.html-CcQLSzcv.js" as="script"><link rel="prefetch" href="/assets/markdown.html-Z5BwcGv9.js" as="script"><link rel="prefetch" href="/assets/page.html-CXRNYHiA.js" as="script"><link rel="prefetch" href="/assets/NaN判断.html-CjXG0Zxk.js" as="script"><link rel="prefetch" href="/assets/elementUI中input回车触发页面刷新问题和解决方法.html-Cgd9VdLk.js" as="script"><link rel="prefetch" href="/assets/vue router.html-BqOuMJ4K.js" as="script"><link rel="prefetch" href="/assets/vue3 computed不能及时更新.html-DikYRTxU.js" as="script"><link rel="prefetch" href="/assets/vue3多层级复选框.html-BwY9drUe.js" as="script"><link rel="prefetch" href="/assets/vue3实现多层级的动态表单增减.html-oGRFUkFr.js" as="script"><link rel="prefetch" href="/assets/vue3实现按钮级权限.html-B-HFJFFo.js" as="script"><link rel="prefetch" href="/assets/vue3自定义指令实现截图.html-BYJaa-W-.js" as="script"><link rel="prefetch" href="/assets/个人前端判断新增名称重复.html-CZtlTxi9.js" as="script"><link rel="prefetch" href="/assets/使用伪类在原来样式的基础上添加一个边框.html-vFyApssy.js" as="script"><link rel="prefetch" href="/assets/修改当前路由地址参数重新刷新页面.html-BwKDK_P-.js" as="script"><link rel="prefetch" href="/assets/关系图谱后端不给指向性字段使用children.html-Y4aBbUDC.js" as="script"><link rel="prefetch" href="/assets/删除远程分支.html-Bpxz5rmv.js" as="script"><link rel="prefetch" href="/assets/后台发货动态校验多包裹及校验可选择发货数量.html-44ifX6no.js" as="script"><link rel="prefetch" href="/assets/对组织树操作.html-DHQN3d7D.js" as="script"><link rel="prefetch" href="/assets/更改数据结构..html-B3YSyXLM.js" as="script"><link rel="prefetch" href="/assets/根据A的数组的顺序对数组B相同的属性排序.html-CyuNc4UI.js" as="script"><link rel="prefetch" href="/assets/调试npm.html-CTXsaVF-.js" as="script"><link rel="prefetch" href="/assets/防止按钮多次连续点击.html-DYYIisIf.js" as="script"><link rel="prefetch" href="/assets/博主.html-C4jEgckP.js" as="script"><link rel="prefetch" href="/assets/JS对于字符串的切割截取.html-C0cKvp1s.js" as="script"><link rel="prefetch" href="/assets/JavaScript取出字符串中括号里的内容.html-DXNd3NMK.js" as="script"><link rel="prefetch" href="/assets/h5 抽奖功能.html-CklV2bzq.js" as="script"><link rel="prefetch" href="/assets/js去除字符串空格(空白符).html-D78Agqcj.js" as="script"><link rel="prefetch" href="/assets/js数组及对象数组取交集，并集，补集的方法H .html-C8X96uC1.js" as="script"><link rel="prefetch" href="/assets/一些小技巧应用.html-BP4mwK8o.js" as="script"><link rel="prefetch" href="/assets/如何实现将一个对象数组转为二维数组.html-e5bptl4l.js" as="script"><link rel="prefetch" href="/assets/对象的补集，差集等.html-BEGkdw_1.js" as="script"><link rel="prefetch" href="/assets/改变数据结构的方法.html-9wK1_yNL.js" as="script"><link rel="prefetch" href="/assets/数组扁平化.html-ChcxLKkE.js" as="script"><link rel="prefetch" href="/assets/Day.js 常用方法.html-C3vNXrkz.js" as="script"><link rel="prefetch" href="/assets/Pinia入门使用.html-MzjIXPQf.js" as="script"><link rel="prefetch" href="/assets/vue cli3.0快速搭建项目详解（强烈推荐）.html-43vwOYF_.js" as="script"><link rel="prefetch" href="/assets/微前端-qiankun.html-B87HQ-8T.js" as="script"><link rel="prefetch" href="/assets/微前端.html-CU5KFFgq.js" as="script"><link rel="prefetch" href="/assets/MongoDB Atlas 云数据库配置 _ 文档 CRUD 操作.html-Cy_-qGfm.js" as="script"><link rel="prefetch" href="/assets/Node.js 使用 Express 中间件实现文件读取 HTTP 接口.html-Bbe1vatv.js" as="script"><link rel="prefetch" href="/assets/Node.js 网页爬虫开发指南（含完整注释版）.html-DcTgkvyD.js" as="script"><link rel="prefetch" href="/assets/React实现前端低代码开发：从架构设计到实践落地.html-hAXuR_K5.js" as="script"><link rel="prefetch" href="/assets/useState源码实现与Vue3响应式系统差异对比.html-DD0Iwl9r.js" as="script"><link rel="prefetch" href="/assets/webWorker 使用与解析.html-Bu089TN6.js" as="script"><link rel="prefetch" href="/assets/微前端沙箱实现原理全解析与 qiankun 对比实践.html-c5MKxcuU.js" as="script"><link rel="prefetch" href="/assets/流式传输 (Streaming) 与 Suspense 边界配置讲解与实际应用.html-DpZxYldp.js" as="script"><link rel="prefetch" href="/assets/🚀 Next.js 缓存机制解析unstable_cache vs revalidate.html-BWWBO2mG.js" as="script"><link rel="prefetch" href="/assets/🚀 Vercel部署实践指南.html-C1uWLZDR.js" as="script"><link rel="prefetch" href="/assets/🚀 从零手写一个微前端沙箱：对标 Qiankun 的完整实现与原理解析.html-CoRvMhUM.js" as="script"><link rel="prefetch" href="/assets/🚀React useState源码实现 vs Vue 3 响应式机制差异解析.html-BCz7OKyN.js" as="script"><link rel="prefetch" href="/assets/🚨 全栈错误处理实战指南：从前端到后端的多维应对策略.html-BJ28N1J-.js" as="script"><link rel="prefetch" href="/assets/🧠 Next.js 高级讲解.html-B_ElxWDU.js" as="script"><link rel="prefetch" href="/assets/ES6.html-BCpo0LUo.js" as="script"><link rel="prefetch" href="/assets/event事件.html-Dkapuxgw.js" as="script"><link rel="prefetch" href="/assets/js运行机制.html-DlJYGHLn.js" as="script"><link rel="prefetch" href="/assets/创建对象.html-CzYkLUCc.js" as="script"><link rel="prefetch" href="/assets/原型链.html-DxxvKPnu.js" as="script"><link rel="prefetch" href="/assets/垃圾回收机制.html-CW7f-lyl.js" as="script"><link rel="prefetch" href="/assets/字符串.html-C-d2MlWc.js" as="script"><link rel="prefetch" href="/assets/数组方法.html-CSu-AyQz.js" as="script"><link rel="prefetch" href="/assets/错误捕获.html-CNzprrqF.js" as="script"><link rel="prefetch" href="/assets/闭包.html-DXCzAraF.js" as="script"><link rel="prefetch" href="/assets/css3.html-CYgXe3Df.js" as="script"><link rel="prefetch" href="/assets/布局.html-CZEqRs6C.js" as="script"><link rel="prefetch" href="/assets/html-css-render.html-CAeBKKPO.js" as="script"><link rel="prefetch" href="/assets/html.html-EXHOGQIK.js" as="script"><link rel="prefetch" href="/assets/Object-defineProperty.html-C0PHAql9.js" as="script"><link rel="prefetch" href="/assets/Vue3.html-DaHtm5fN.js" as="script"><link rel="prefetch" href="/assets/vue.html-B6vxabVz.js" as="script"><link rel="prefetch" href="/assets/deploy.html-DGUkoqG0.js" as="script"><link rel="prefetch" href="/assets/性能优化.html-83YSa8ib.js" as="script"><link rel="prefetch" href="/assets/缓存.html-CDCjCMXh.js" as="script"><link rel="prefetch" href="/assets/JS笔试题.html-B_lGvwnz.js" as="script"><link rel="prefetch" href="/assets/手写面试题.html-BMec_hM1.js" as="script"><link rel="prefetch" href="/assets/笔试题 每日3_1.html-CFe9e0KN.js" as="script"><link rel="prefetch" href="/assets/算法基础.html-BosCRfsf.js" as="script"><link rel="prefetch" href="/assets/简历陈述.html-BByzjvEl.js" as="script"><link rel="prefetch" href="/assets/经典问题.html-DURN-F2A.js" as="script"><link rel="prefetch" href="/assets/404.html-BlNetaqQ.js" as="script"><link rel="prefetch" href="/assets/index.html-H2kj2qOD.js" as="script"><link rel="prefetch" href="/assets/index.html-BHLUOFBX.js" as="script"><link rel="prefetch" href="/assets/index.html-U8JRK23f.js" as="script"><link rel="prefetch" href="/assets/index.html-bet6dxav.js" as="script"><link rel="prefetch" href="/assets/index.html-IG_mykgI.js" as="script"><link rel="prefetch" href="/assets/index.html-ByZFH-Gi.js" as="script"><link rel="prefetch" href="/assets/index.html-EAaR0k-_.js" as="script"><link rel="prefetch" href="/assets/index.html-vW98jZ4-.js" as="script"><link rel="prefetch" href="/assets/index.html-BIoigWtf.js" as="script"><link rel="prefetch" href="/assets/index.html--jUkzOw6.js" as="script"><link rel="prefetch" href="/assets/index.html--5u13Z1p.js" as="script"><link rel="prefetch" href="/assets/index.html-C-TLjI0S.js" as="script"><link rel="prefetch" href="/assets/index.html-C9zm6vO2.js" as="script"><link rel="prefetch" href="/assets/giscus-D-fkNSKD.js" as="script"><link rel="prefetch" href="/assets/photoswipe.esm-GXRgw7eJ.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="vp-skip-link sr-only">跳至主要內容</a><!--]--><div class="theme-container external-link-icon has-toc"><!--[--><header id="navbar" class="vp-navbar"><div class="vp-navbar-start"><button type="button" class="vp-toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><!----><!--[--><a class="route-link vp-brand" href="/"><img class="vp-nav-logo" src="https://theme-hope-assets.vuejs.press/logo.svg" alt><!----><span class="vp-site-name hide-in-pad">前端知识随笔</span></a><!--]--><!----></div><div class="vp-navbar-center"><!----><!--[--><nav class="vp-nav-links"><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/portfolio.html" aria-label="个人信息"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-home" style=""></span><!--]-->个人信息<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link auto-link" href="/frontEndInterview/" aria-label="前端面试指南"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-laptop-code" style=""></span><!--]-->前端面试指南<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="route-link route-link-active auto-link" href="/businessProblem/" aria-label="前端业务"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-person-chalkboard" style=""></span><!--]-->前端业务<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="auto-link external-link" href="https://next-vite-delta.vercel.app/#/home" aria-label="个人全栈项目" rel="noopener noreferrer" target="_blank"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-person-chalkboard" style=""></span><!--]-->个人全栈项目<!----></a></div><div class="vp-nav-item hide-in-mobile"><a class="auto-link external-link" href="https://www.yuque.com/an31742" aria-label="语雀" rel="noopener noreferrer" target="_blank"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-person-chalkboard" style=""></span><!--]-->语雀<!----></a></div></nav><!--]--><!----></div><div class="vp-navbar-end"><!----><!--[--><!----><div class="vp-nav-item vp-action"><a class="vp-action-link" href="https://github.com/an31742" target="_blank" rel="noopener noreferrer" aria-label="GitHub"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="github icon" name="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></svg></a></div><div class="vp-nav-item hide-in-mobile"><button type="button" class="vp-color-mode-switch" id="color-mode-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="auto icon" name="auto" style="display:block;"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="dark icon" name="dark" style="display:none;"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="light icon" name="light" style="display:none;"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></svg></button></div><!----><!--]--><!----><button type="button" class="vp-toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span><span class="vp-top"></span><span class="vp-middle"></span><span class="vp-bottom"></span></span></button></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow start"></span></div><aside id="sidebar" class="vp-sidebar"><!----><ul class="vp-sidebar-links"><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">个人解决</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">优秀博主</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">常用方法使用</span><span class="vp-arrow end"></span></button><!----></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable active" type="button"><!----><span class="vp-sidebar-title">新知识</span><span class="vp-arrow down"></span></button><ul class="vp-sidebar-links"><li><a class="route-link auto-link vp-sidebar-link" href="/businessProblem/%E6%96%B0%E7%9F%A5%E8%AF%86/Day.js%20%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95.html" aria-label="Day.js 常用方法"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-circle-info" style=""></span><!--]-->Day.js 常用方法<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/businessProblem/%E6%96%B0%E7%9F%A5%E8%AF%86/vue%20cli3.0%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E8%AF%A6%E8%A7%A3%EF%BC%88%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90%EF%BC%89.html" aria-label="vue cli3.0快速搭建项目详解（强烈推荐）"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-circle-info" style=""></span><!--]-->vue cli3.0快速搭建项目详解（强烈推荐）<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/businessProblem/%E6%96%B0%E7%9F%A5%E8%AF%86/Pinia%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8.html" aria-label="什么是Pinia"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-circle-info" style=""></span><!--]-->什么是Pinia<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/businessProblem/%E6%96%B0%E7%9F%A5%E8%AF%86/%E5%BE%AE%E5%89%8D%E7%AB%AF.html" aria-label="微前端"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-circle-info" style=""></span><!--]-->微前端<!----></a></li><li><a class="route-link auto-link vp-sidebar-link" href="/businessProblem/%E6%96%B0%E7%9F%A5%E8%AF%86/%E5%BE%AE%E5%89%8D%E7%AB%AF-qiankun.html" aria-label="微前端-qiankun"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-circle-info" style=""></span><!--]-->微前端-qiankun<!----></a></li><li><a class="route-link route-link-active auto-link vp-sidebar-link active" href="/businessProblem/%E6%96%B0%E7%9F%A5%E8%AF%86/%E3%80%90%E9%95%BF%E6%96%87%E3%80%91%E5%8F%AA%E4%BC%9A%20Vue%20%E4%B8%8D%E4%BC%9A%20React%20%EF%BC%9F22%20%E7%82%B9%E8%AF%81%E6%98%8E%20React%20%E6%AF%94%20Vue3%20%E6%9B%B4%E7%AE%80%E5%8D%95.html" aria-label="简单入门react"><!--[--><span class="font-icon icon fa-fw fa-sm fas fa-circle-info" style=""></span><!--]-->简单入门react<!----></a></li></ul></section></li><li><section class="vp-sidebar-group"><button class="vp-sidebar-header clickable" type="button"><!----><span class="vp-sidebar-title">进阶</span><span class="vp-arrow end"></span></button><!----></section></li></ul><!----></aside><!--[--><main id="main-content" class="vp-page"><!--[--><!----><!----><nav class="vp-breadcrumb disable"></nav><div class="vp-page-title"><h1><span class="font-icon icon fa-fw fa-sm fas fa-circle-info" style=""></span>简单入门react</h1><div class="page-info"><span class="page-author-info" aria-label="作者🖊" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="author icon" name="author"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></svg><span><a class="page-author-item" href="https://github.com/an31742" target="_blank" rel="noopener noreferrer">小安</a></span><span property="author" content="小安"></span></span><!----><span class="page-date-info" aria-label="写作日期📅" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="calendar icon" name="calendar"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></svg><span><!----></span><meta property="datePublished" content="2024-06-28T01:37:54.000Z"></span><!----><span class="page-reading-time-info" aria-label="阅读时间⌛" data-balloon-pos="up"><svg xmlns="http://www.w3.org/2000/svg" class="icon timer-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="timer icon" name="timer"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z"></path></svg><span>大约 26 分钟</span><meta property="timeRequired" content="PT26M"></span><!----><!----></div><hr></div><div class="vp-toc-placeholder"><aside id="toc"><!----><div class="vp-toc-header">此页内容<button type="button" class="print-button" title="打印"><svg xmlns="http://www.w3.org/2000/svg" class="icon print-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="print icon" name="print"><path d="M819.2 364.8h-44.8V128c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v236.8h-44.8C145.067 364.8 96 413.867 96 473.6v192c0 59.733 49.067 108.8 108.8 108.8h44.8V896c0 17.067 14.933 32 32 32h460.8c17.067 0 32-14.933 32-32V774.4h44.8c59.733 0 108.8-49.067 108.8-108.8v-192c0-59.733-49.067-108.8-108.8-108.8zM313.6 160h396.8v204.8H313.6V160zm396.8 704H313.6V620.8h396.8V864zM864 665.6c0 25.6-19.2 44.8-44.8 44.8h-44.8V588.8c0-17.067-14.933-32-32-32H281.6c-17.067 0-32 14.933-32 32v121.6h-44.8c-25.6 0-44.8-19.2-44.8-44.8v-192c0-25.6 19.2-44.8 44.8-44.8h614.4c25.6 0 44.8 19.2 44.8 44.8v192z"></path></svg></button><div class="arrow end"></div></div><div class="vp-toc-wrapper"><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#开始">开始</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#创建项目">创建项目</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#组件">组件</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#组件定义">组件定义</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#组件结构">组件结构</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#组件属性">组件属性</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#组件事件">组件事件</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#子组件">子组件</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#模板">模板</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#插值">插值</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#属性">属性</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#自定义事件">自定义事件</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#样式">样式</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#dom-事件">DOM 事件</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#条件渲染">条件渲染</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#列表渲染">列表渲染</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#整体对比">整体对比</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#状态和响应式">状态和响应式</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#值类型">值类型</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#附-react-也有-ref">（附：React 也有 ref）</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#对象和数组">对象和数组</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#数据的复杂性">数据的复杂性</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#副作用和组件生命周期">副作用和组件生命周期</a></li><li><ul class="vp-toc-list"><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#附-纯函数和副作用">（附：纯函数和副作用）</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#初次渲染">初次渲染</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#组件更新">组件更新</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#组件销毁">组件销毁</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level3" href="#watch-computed">watch computed</a></li><!----><!--]--></ul></li><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#表单">表单</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#开发-todo-list-项目">开发 todo-list 项目</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#react-很简单">React 很简单</a></li><!----><!--]--><!--[--><li class="vp-toc-item"><a class="route-link vp-toc-link level2" href="#"></a></li><!----><!--]--></ul><div class="vp-toc-marker" style="top:-1.7rem;"></div></div><!----></aside></div><!----><div class="theme-hope-content"><p>转载自<a href="https://juejin.cn/post/7344536653463207973" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/7344536653463207973</a></p><p>真看完本文，将打破 “React 难” 的认知。你只要会 JS 就会 React</p><h2 id="开始" tabindex="-1"><a class="header-anchor" href="#开始"><span>开始</span></a></h2><p>大家好，我是 双越老师~ 现在还有大量的前端同学只会 Vue 不会 React，想学吧也不知道从何入手，也感觉自己没时间。 同时，现在已经有大量的公司招聘要求 React 技术栈，纯 Vuer 投简历时候只能躲着走，望之兴叹。 也不知道从何时开始，一直到现在，还流传着“Vue 简单，React 难”这样一个论调。 这个“难”可以理解为有难度，也可以理解为设计的难用、反人性。反正就是难。 <img src="https://cdn.nlark.com/yuque/0/2024/webp/28199172/1719452106891-68bcc31e-931d-4323-940b-97db42ccdcd8.webp#averageHue=%23c0aea9&amp;clientId=u0044065a-f65d-4&amp;from=paste&amp;id=u3d37f71d&amp;originHeight=646&amp;originWidth=2020&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=uac51fa69-dacb-4254-9112-6efc7cae44f&amp;title=" alt="" loading="lazy"> 其实 React 并不难，尤其是 Hooks 普及以后，更加简单了，比 Vue3 还简单。 本文我对比着 Vue2 Vue3，把 React 22 个基础技能过一遍，看看 React 到底难在哪里。 你可以顺序看，遇到看不懂的就给我评论，保证给你解释清楚。 此外，我们一边学习 React 基础技能，一遍做一个 todo-list 项目，学以致用。源码在文末。 <img src="https://cdn.nlark.com/yuque/0/2024/webp/28199172/1719452106968-9b9054a6-621a-486f-899f-615b7d5a2445.webp#averageHue=%23f6f6f6&amp;clientId=u0044065a-f65d-4&amp;from=paste&amp;id=ud2e6896e&amp;originHeight=490&amp;originWidth=1642&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u337da7e3-2874-4dd4-93ea-bdab7a8c5d9&amp;title=" alt="" loading="lazy"> 如果不满足于一个 demo ，可以来跟我一起做一个 <strong>React Next.js Node 全栈 AIGC 项目 <strong><a href="https://link.juejin.cn?target=https%3A%2F%2Fhuashuiai.com%2F" target="_blank" rel="noopener noreferrer">划水AI</a></strong>，仿 Notioin AI 和协同编辑</strong>。项目介绍可以看<a href="https://juejin.cn/post/7338797433899221043" target="_blank" rel="noopener noreferrer">这里</a>，有意私信我～</p><h2 id="创建项目" tabindex="-1"><a class="header-anchor" href="#创建项目"><span>创建项目</span></a></h2><p>先使用 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcreate-react-app.dev%2Fdocs%2Fgetting-started" target="_blank" rel="noopener noreferrer">create-react-app</a> 脚手架创建一个 React 项目，并启动项目。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>sql</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码npx create-react-app react-todo-list</span></span>
<span class="line"><span>cd react-todo-list</span></span>
<span class="line"><span>npm start</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>PS：React <a href="https://link.juejin.cn?target=https%3A%2F%2Freact.dev%2F" target="_blank" rel="noopener noreferrer">官网</a>已经不推荐使用 create-react-app 了，但这里并不影响本文的学习和使用。</p><h2 id="组件" tabindex="-1"><a class="header-anchor" href="#组件"><span>组件</span></a></h2><p>无论 Vue 还是 React ，页面都是由一个一个组件嵌套组成的，让我们先从组件开始。</p><h3 id="组件定义" tabindex="-1"><a class="header-anchor" href="#组件定义"><span>组件定义</span></a></h3><p>Vue 项目中，组件是一个 .vue 文件，包含模板、样式和脚本代码，这和 HTML 文件格式一样，所以很好理解。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>html</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码&lt;template&gt;</span></span>
<span class="line"><span>    &lt;p&gt;hello vue&lt;/p&gt;</span></span>
<span class="line"><span>&lt;/template&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;script&gt;</span></span>
<span class="line"><span>export default {</span></span>
<span class="line"><span>    // ...</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>&lt;/script&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>&lt;style&gt;&lt;/style&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React 组件一般是一个 JS 文件，用一个 JS 函数定义组件。组件函数会返回一段 JSX 代码，JSX 语法和 HTML 语法很相似，也很好理解。 【实战】把你的 React src/App.js 改为如下代码：</p><div class="language-js line-numbers-mode" data-highlighter="shiki" data-ext="js" data-title="js" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">复制代码</span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// src/App.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> App</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;"> (</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    // JSX 语法，类似于 HTML</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">      &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;hello React&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#E06C75;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  )</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> App</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>记得当年对 React 的吐槽主要在于：在 JS 中写 HTML 会导致混乱。 因为那会儿还是 jQuery 时代，HTML 本来就是把 JS 单独分离到 script 中的，大家习惯了这样做，而且没见过 React 这种写法，接受不了。相比之下还是 Vue 写法更好接受。 但随着 React 慢慢的推广使用，近 10 年过去了，现在再也听不到这种吐槽的声音了。 而且，现在 React Vue 发展多年，我们再思考一个问题：组件是否应该是一个函数才合理呢？ 输入数据，返回 UI 。Vue 也很早就支持了函数组件。 所以，React 本质是 JS 函数，这不难吧。至于 JSX ，后面再讲。</p><h3 id="组件结构" tabindex="-1"><a class="header-anchor" href="#组件结构"><span>组件结构</span></a></h3><p>无论 Vue React 都是支持组件嵌套的，嵌套规则和格式也都是参考 HTML 语法。 对于自定义组件的 tag 名称，Vue 和 React 现在都推荐使用 PascalCase 写法，如 <!---->，即首字母大写。 PS：Vue2 当年推荐 <!----> 写法，Vue3 改过来了。 【实战】在你的 React 项目中新建一个 src/components 目录，然后再其中新建两个文件：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码// src/components/TodoInput.js</span></span>
<span class="line"><span>function TodoInput() {</span></span>
<span class="line"><span>  return (</span></span>
<span class="line"><span>    &lt;div&gt;</span></span>
<span class="line"><span>      &lt;p&gt;todo input&lt;/p&gt;</span></span>
<span class="line"><span>    &lt;/div&gt;</span></span>
<span class="line"><span>  )</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>export default TodoInput</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码// src/components/TodoList.js</span></span>
<span class="line"><span>function TodoList() {</span></span>
<span class="line"><span>  return (</span></span>
<span class="line"><span>    &lt;div&gt;</span></span>
<span class="line"><span>      &lt;p&gt;todo list&lt;/p&gt;</span></span>
<span class="line"><span>    &lt;/div&gt;</span></span>
<span class="line"><span>  )</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>export default TodoList</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后把现有的 App.js 修改为如下代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码// src/App.js</span></span>
<span class="line"><span>import TodoInput from &#39;./components/TodoInput&#39;</span></span>
<span class="line"><span>import TodoList from &#39;./components/TodoList&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function App() {</span></span>
<span class="line"><span>  return (</span></span>
<span class="line"><span>    &lt;div&gt;</span></span>
<span class="line"><span>      &lt;TodoInput /&gt;</span></span>
<span class="line"><span>      &lt;TodoList /&gt;</span></span>
<span class="line"><span>    &lt;/div&gt;</span></span>
<span class="line"><span>  )</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>export default App</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>组件结构，这不难吧？和 Vue 一样。</p><h3 id="组件属性" tabindex="-1"><a class="header-anchor" href="#组件属性"><span>组件属性</span></a></h3><p>Vue 组件接收属性时，需要用 props: [&#39;a&#39;, &#39;b&#39;] 来定义各个属性的名称。即便是 Vue3 setup script 也需要一个 defineProps([&#39;a&#39;, &#39;b&#39;]) 一个宏来定义。这种写法是 Vue 组件独有的，Vue 发明的。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码export default {</span></span>
<span class="line"><span>  props: [&#39;foo&#39;],</span></span>
<span class="line"><span>  setup(props) {</span></span>
<span class="line"><span>    console.log(props.foo) // setup() 接收 props 作为第一个参数</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>而 React 组件是一个函数，它的属性就是函数的参数</strong>，就是如此简单。 PS：对比上面 Vue 代码和下面 React 代码，你可能会疑问：同样是获取 props.foo ，为何 Vue 需要定义 props: [&#39;foo&#39;] 呢？ 【实战】把 src/components/TodoList.js 内容改为如下代码</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码// src/components/TodoList.js</span></span>
<span class="line"><span>function TodoList(props) {</span></span>
<span class="line"><span>  console.log(props.foo)</span></span>
<span class="line"><span>  return (</span></span>
<span class="line"><span>    &lt;div&gt;</span></span>
<span class="line"><span>      &lt;p&gt;todo list&lt;/p&gt;</span></span>
<span class="line"><span>    &lt;/div&gt;</span></span>
<span class="line"><span>  )</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>export default TodoList</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>【实战】然后把 src/App.js 中 <!----> 改为如下代码 。刷新浏览器即可看到打印结果。（PS：为何打印两次？欢迎给我评论，我来给你解释。）</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>html</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码&lt;TodoList foo=&quot;hello foo&quot; /&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，React 组件属性，就是函数参数，这简单吧。</p><h3 id="组件事件" tabindex="-1"><a class="header-anchor" href="#组件事件"><span>组件事件</span></a></h3><p>Vue 组件的事件，可以不定义，直接通过 this.$emit(&#39;xxx&#39;) 触发即可。这样其实不好，</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码methods: {</span></span>
<span class="line"><span>    deleteItem(id) { this.$emit(&#39;delete&#39;, id) }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>或者 Vue3 setup script 中使用 defineEmits 这个宏来定义。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>html</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码&lt;script setup&gt;</span></span>
<span class="line"><span>const emit = defineEmits([&#39;inFocus&#39;, &#39;submit&#39;])</span></span>
<span class="line"><span>function buttonClick() { emit(&#39;submit&#39;) }</span></span>
<span class="line"><span>&lt;/script&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这两种方式：</p><ul><li>不定义，你就不知道这个事件的来源，就需要去全局查找。如果名称不小心写错了，也无法提前报错提示。</li><li>使用 defineEmits 定义，就和上面 props 一样，又是 Vue 独有的语法。包括使用 $emit 去执行，也是 Vue 独有的。都需要你挨个学习，用的时候挨个去看文档。</li></ul><p><strong>反观 React：组件事件和属性一样，还是函数的参数，执行事件就是执行一个函数，就简单的 JS 代码。</strong> 【实战】把 src/components/TodoInput.js 代码改为</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码// src/components/TodoInput.js</span></span>
<span class="line"><span>function TodoInput(props) {</span></span>
<span class="line"><span>  const { addTodo } = props // 解构出事件 addTodo</span></span>
<span class="line"><span>  function addTodoHandler() {</span></span>
<span class="line"><span>    addTodo(&#39;some text&#39;) // 执行事件 addTodo ，随便传入参数</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  return (</span></span>
<span class="line"><span>    &lt;div&gt;</span></span>
<span class="line"><span>      &lt;p onClick={addTodoHandler}&gt;todo input&lt;/p&gt; {/* 这里的 onClick 写法，先不要管，后面会讲 */}</span></span>
<span class="line"><span>    &lt;/div&gt;</span></span>
<span class="line"><span>  )</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>export default TodoInput</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>【实战】并且把 src/App.js 改为如下代码。刷新浏览器，点击网页中的 todo input 文字，即可看到打印效果。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码import TodoInput from &#39;./components/TodoInput&#39;</span></span>
<span class="line"><span>import TodoList from &#39;./components/TodoList&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function App() {</span></span>
<span class="line"><span>  function addTodo(t) {</span></span>
<span class="line"><span>    console.log(&#39;addTodo: &#39;, t)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  return (</span></span>
<span class="line"><span>    &lt;div&gt;</span></span>
<span class="line"><span>      &lt;TodoInput addTodo={addTodo} /&gt;</span></span>
<span class="line"><span>      &lt;TodoList foo=&quot;hello foo&quot; /&gt;</span></span>
<span class="line"><span>    &lt;/div&gt;</span></span>
<span class="line"><span>  )</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>export default App</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，React 组件的事件，也是函数参数，执行就是执行 JS 函数，这简单吧。</p><h3 id="子组件" tabindex="-1"><a class="header-anchor" href="#子组件"><span>子组件</span></a></h3><p>你熟悉 Vue 应该知道 slot 插槽，用于定义和显示子组件的内容。 而且，Vue 文档中关于 slot 的功能非常多，例如具名插槽、作用域插槽… 说起来我自己都糊涂。 而 React 关于子组件的，只有一个 props.children —— 对，children 就是一个普通的属性，只不过你不用显示的传递过来。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>jsx</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码function Layout({ children }) {</span></span>
<span class="line"><span>    return &lt;div&gt;</span></span>
<span class="line"><span>        &lt;Nav /&gt;  {/* 导航栏 */}</span></span>
<span class="line"><span>        &lt;div&gt;{children}&lt;/div&gt;  {/* 子组件 */}</span></span>
<span class="line"><span>    &lt;/div&gt;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你可能会疑问，Vue slot 那么多功能，而 React 只有一个 children ，这能满足开发需求吗？ 当然可以，近 10 年了，依然只有一个 children ，如果满足不了，早就扩展了。</p><h2 id="模板" tabindex="-1"><a class="header-anchor" href="#模板"><span>模板</span></a></h2><p>模板，即组件的 UI 结构。Vue 使用自己的 template 模板语法，React 使用 JSX 语法。 JSX 当年刚被 React 发明出来时，也是备受吐槽的，但也慢慢的成为了社区写 UI 的标准，很多框架支持用 JSX （包括 Vue3），babel 默认支持 JSX 编译，<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.typescriptlang.org%2Fdocs%2Fhandbook%2Fjsx.html" target="_blank" rel="noopener noreferrer">TS</a> 也支持 JSX 语法。 JSX 现在被应用如此广泛，其实已经可以说明问题了：JSX 很好用。如果它设计复杂难度大，谁会用它呢？ PS：不要跟我说“Vue3 也可以用 JSX”这种话。我不看“也可以”，我只看它推荐用什么（即文档中大部分都用什么）。Vue 有可以用 defineComponent 定义组件，你怎么不用呢？<strong>开发人员最怕“也可以”，也可以这样，也可以那样，那该如何选择呢？</strong> 就像你请女朋友吃饭吃什么，她说“都行”，你就犯难了。</p><h3 id="插值" tabindex="-1"><a class="header-anchor" href="#插值"><span>插值</span></a></h3><p>普通文本的插值，Vue template 使用  ，JSX 使用 {name} ，都很简单。</p><h3 id="属性" tabindex="-1"><a class="header-anchor" href="#属性"><span>属性</span></a></h3><p>Vue template 使用 :xxx 来区分属性值的类型，如下代码。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>html</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码&lt;p id=&quot;p1&quot; :title=&quot;title1&quot;&gt;hello vue&lt;/p&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的 p1 就只字符串，而 title1 就是一个 JS 变量。所以这个 :xxx 又是一个 Vue 新定义的语法规则。 而 React JSX 中，属性值如果是 JS 变量，依然用插值的语法 {name} ，没增加新规则。如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>html</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码&lt;p id=&quot;p1&quot; title={title}&gt;hello vue&lt;/p&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React 动态属性，依然使用 插值 语法，很简单。 PS：Vue 有 props 和 attrs （后者面试常考但工作不常用），React 没有 attrs ，也不耽误用。</p><h3 id="自定义事件" tabindex="-1"><a class="header-anchor" href="#自定义事件"><span>自定义事件</span></a></h3><p>往子组件中传入自定义事件，Vue template 需要使用 @xxx 写法。（子组件定义事件，上文已说）</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>html</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码&lt;MyComponent @some-event=&quot;callback&quot; /&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而 React 依然使用 插值 语法 {xxx} ，一个规则到处用。看你 src/App.js 代码中：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>html</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码&lt;TodoInput addTodo={addTodo} /&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="样式" tabindex="-1"><a class="header-anchor" href="#样式"><span>样式</span></a></h3><p>普通的 class ，Vue template 使用 class=&quot;a b&quot; ，React JSX 使用 className=&quot;a b&quot; 。 因为 React 完全是 JS 代码，class 是 JS 的关键字，没法直接使用，所以必须用 className 代替。 这一点不难理解。 如果是动态 class ，Vue 有多种写法（对象、数组）可以自己去看<a href="https://link.juejin.cn?target=https%3A%2F%2Fcn.vuejs.org%2Fguide%2Fessentials%2Fclass-and-style.html" target="_blank" rel="noopener noreferrer">文档</a>，这都是 Vue 独家发明。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>html</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码&lt;div :class=&quot;{ active: isActive }&quot;&gt;&lt;/div&gt;</span></span>
<span class="line"><span>&lt;div :class=&quot;[isActive ? activeClass : &#39;&#39;, errorClass]&quot;&gt;&lt;/div&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p xxx="">而 React 继续以不变应万变 —— 还是使用 插值 语法</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码&lt;div className={someClass}&gt;&lt;/div&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你会发现在 JSX 中，一个 {xxx} 写法，可以解决大部分问题，而在 Vue template 中需要很多规则。那个更简单呢？</p><h3 id="dom-事件" tabindex="-1"><a class="header-anchor" href="#dom-事件"><span>DOM 事件</span></a></h3><p>Vue template 绑定 DOM 事件使用 @xxx 格式，和上文的自定义事件一样。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>html</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码&lt;button @click=&quot;greet&quot;&gt;Greet&lt;/button&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React JSX 绑定 DOM 事件参考了 <a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.runoob.com%2Ftags%2Fref-eventattributes.html" target="_blank" rel="noopener noreferrer">HTML 事件</a> 的语法，但加了一个规定：使用驼峰式写法。看你 src/components/TodoInput.js 的代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>html</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码&lt;p onClick={addTodoHandler}&gt;todo input&lt;/p&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>所以，JSX 中所有 onXxx 就是 DOM 事件的写法。这是 JSX 除了插值语法的第二个规则，需要记住。 PS：对于上文的“自定义事件”，Vue 理解为是“事件”，所以用 @xxx 语法；而 React 理解为是“属性”，写法和 onXxx 不一样，和属性一样。你更倾向于是哪一个？</p><h3 id="条件渲染" tabindex="-1"><a class="header-anchor" href="#条件渲染"><span>条件渲染</span></a></h3><p>Vue template 使用 v-if 和 v-else 等指令实现判断逻辑条件渲染，又是 Vue 独家发明。注意，其中的 awesome 是一个 JS 变量，别误看做是静态的。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>html</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码&lt;h1 v-if=&quot;awesome&quot;&gt;Vue is awesome!&lt;/h1&gt;</span></span>
<span class="line"><span>&lt;h1 v-else&gt;Oh no 😢&lt;/h1&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React JSX 依然使用 {xxx} ，只不过不是用 JS 变量，而是<strong>使用 JS 表达式</strong>。 我们先简单做一个 JS 的练习测试。执行如下代码，分别打印什么？</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码const flag1 = true</span></span>
<span class="line"><span>flag1 &amp;&amp; &#39;hello&#39; // 打印什么</span></span>
<span class="line"><span>flag1 ? &#39;a&#39; : &#39;b&#39; // 打印什么</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const flag2 = false</span></span>
<span class="line"><span>flag2 &amp;&amp; &#39;hello&#39; // 打印什么</span></span>
<span class="line"><span>flag2 ? &#39;a&#39; : &#39;b&#39; // 打印什么</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>具体打印的结果，可以自己执行一下看看。如果你通过了这个小测试，那继续看代码：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>jsx</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码{ flag &amp;&amp; &lt;SomeComponent /&gt; }</span></span>
<span class="line"><span>{ flag ? &lt;SomeCompnent/&gt; : &lt;OtherComponent/&gt; }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果 flag 是 true，那两个表达式返回什么？ —— 答案是返回 <!----> 组件。 即，如果 flag 是 true 上述代码就等同于</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>html</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码&lt;SomeComponent /&gt;</span></span>
<span class="line"><span>&lt;SomeComponent /&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>能看懂就继续，看不懂就给我留言评论。 【实战】把你代码中 src/App.js 改为如下代码，自己改一下 list 数组的值，体验一下条件渲染。 <img src="https://cdn.nlark.com/yuque/0/2024/webp/28199172/1719452106980-eef6d0e3-4a82-487a-ba60-9d3c126e7a26.webp#averageHue=%2323201f&amp;clientId=u0044065a-f65d-4&amp;from=paste&amp;id=u3b3de8bc&amp;originHeight=666&amp;originWidth=1742&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u971794fd-622a-4976-a810-deaa1ab3cc5&amp;title=" alt="" loading="lazy"> 所以，如果你能熟悉 JS （这是基本要求）且能理解“{xxx} 内部可使用表达式”，那 JSX 条件渲染就非常简单。</p><h3 id="列表渲染" tabindex="-1"><a class="header-anchor" href="#列表渲染"><span>列表渲染</span></a></h3><p>Vue template 中循环渲染使用 v-for 指令，也是 Vue 独家发明。而且使用 v-for 时有很多说明，文档写的非常多。这都是学习成本啊。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>html</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码&lt;li v-for=&quot;item in items&quot;&gt;</span></span>
<span class="line"><span>  {{ item.message }}</span></span>
<span class="line"><span>&lt;/li&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而 React 还是使用 {xxx} 表达式。其中主要用到 JS 数组的 map 方法，先做一个小练习。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码const arr1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span></span>
<span class="line"><span>const arr2 = arr1.map(item =&gt; {</span></span>
<span class="line"><span>    return item + &#39;s&#39;</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span>console.log(arr1)</span></span>
<span class="line"><span>console.log(arr2)</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>执行结果可以自己亲自试试，如果这个没问题，再继续看下一段代码</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>jsx</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码// 已定义 arr1 = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</span></span>
<span class="line"><span>&lt;ul&gt;</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    arr1.map(item =&gt; {</span></span>
<span class="line"><span>        return &lt;li&gt;{item}&lt;/li&gt;</span></span>
<span class="line"><span>    })</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>&lt;/ul&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>那这段代码执行出来的结果，就等同于如下代码。（看懂就继续，看不懂给我留言~）</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>jsx</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码&lt;ul&gt;</span></span>
<span class="line"><span>    &lt;li&gt;a&lt;/li&gt;</span></span>
<span class="line"><span>    &lt;li&gt;b&lt;/li&gt;</span></span>
<span class="line"><span>    &lt;li&gt;c&lt;/li&gt;</span></span>
<span class="line"><span>&lt;/ul&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>【实战】把你代码 src/components/TodoList.js 改为如下代码</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>jsx</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码function TodoList(props) {</span></span>
<span class="line"><span>  const { list = [] } = props</span></span>
<span class="line"><span>  return (</span></span>
<span class="line"><span>    &lt;ul&gt;</span></span>
<span class="line"><span>      {list.map((item) =&gt; (</span></span>
<span class="line"><span>        &lt;li key={item.id}&gt;{item.text}&lt;/li&gt;</span></span>
<span class="line"><span>      ))}</span></span>
<span class="line"><span>    &lt;/ul&gt;</span></span>
<span class="line"><span>  )</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>export default TodoList</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>【实战】把你代码 src/App.js 做如下修改，刷新页面可看到效果。 <img src="https://cdn.nlark.com/yuque/0/2024/webp/28199172/1719452106987-33962143-f70e-4c78-8a8c-a17b9ba897c2.webp#averageHue=%2322201f&amp;clientId=u0044065a-f65d-4&amp;from=paste&amp;id=uc4fd173c&amp;originHeight=640&amp;originWidth=1772&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u6e87049e-9c42-482b-ab10-264d53a8b5e&amp;title=" alt="" loading="lazy"> PS：Vue 和 React 一样，循环时都需要一个唯一的 key ，否则会有警告。 所以，如果你熟悉了 map 函数，那 JSX 列表渲染也很简单，就是 JS 代码，没有其他规则，没有那么多文档说明。</p><h3 id="整体对比" tabindex="-1"><a class="header-anchor" href="#整体对比"><span>整体对比</span></a></h3><p>JSX 语法非常简洁，记住这两条就够了：</p><ul><li>{xxx} 大括号里面是 JS 的变量或者表达式，可实现一切动态的功能，包括判断和循环</li><li>onXxx 是 DOM 事件的写法</li></ul><p>而 Vue template 定义了更多的规则，需要你多多翻阅文档，例如：</p><ul><li>:xxx 动态属性</li><li>@xxx 事件</li><li>:class 和 :style 的多种写法</li><li>v-ifv-for 等多种指令</li><li>还有更多，如 v-modelslot 等...</li></ul><p>PS：JSX 中 {x} 是动态的， &quot;x&quot; 是静态的，一眼识别，特清晰。而 Vue template 中 &quot;x&quot; 有时候是静态，有时候动态，我还得根据前面的 key 格式去判断，而且格式还那么多，就需要一定的反应时间。这是我个人的一个感觉，不知道你有没有。</p><h2 id="状态和响应式" tabindex="-1"><a class="header-anchor" href="#状态和响应式"><span>状态和响应式</span></a></h2><p>组件的状态数据管理，以及如何触发数据变化，从而触发组件更新。 Vue2 组件使用 data() 函数，Vue3 使用 ref 和 reactive ，Vue 都是响应式监听，直接修改数据即可监听到变化。 Vue2 data 比较简洁明了，我想你也比较熟悉。但 Vue3 的 ref 和 reactive 就带来很多困扰，也在社区激发一些讨论，甚至需要作者出来分析两者用哪个更好。（发现没？又是这种“也可以”的问题） React 就一个 useState API，相比 Vue3 的设计简单很多，我们一一来看。</p><h3 id="值类型" tabindex="-1"><a class="header-anchor" href="#值类型"><span>值类型</span></a></h3><p>值类型，就是比较简单的 number string boolean 等类型。 Vue2 使用 data() 函数返回数据，直接通过 this.xxx 修改数据，非常简单。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码export default {</span></span>
<span class="line"><span>    data() {</span></span>
<span class="line"><span>        return { name: &#39;前端双越老师&#39; }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    method: {</span></span>
<span class="line"><span>        changeName() { this.name = &#39;张三&#39; }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Vue3 处理值类型，要使用 ref ，在 JS 中修改或者使用时，要使用 .value 属性，否则无效。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码const nameRef = ref(&#39;前端双越老师&#39;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function changeName() { nameRef.value = &#39;张三&#39; }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>关于 ref .value 的困扰，之前在 Vue3 社区还讨论过是否要加一些语法糖来去掉 .value 。再后来我也没详细关注，反正现在看 Vue 官网是没直接推荐什么语法糖。如果有了语法糖，也许会写起来更简单，但又会多一个 Vue 自造语法，多一点学习成本。 再看 React 如何处理值类型。React 使用 useState 定义数据和 setXxx 方法。<strong>注意，React 修改数据不是响应式的，要通过 setXxx 来显示修改，是命令式的。</strong> —— 想改谁，想改成啥，你直说，直接调用 setXxx 让大家都明显的看出来，高调一些 —— 这是 React 的风格。 【实战】把你代码中的 src/components/TodoInput.js 改为一下代码，在浏览器刷新测试。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码// src/components/TodoInput.js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import { useState } from &#39;react&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function TodoInput(props) {</span></span>
<span class="line"><span>  const { addTodo } = props</span></span>
<span class="line"><span>  function addTodoHandler() { addTodo(&#39;some text&#39;) }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  const [count, setCount] = useState(0)</span></span>
<span class="line"><span>  function increase() {</span></span>
<span class="line"><span>    setCount(count + 1) //【注意】这里不能写 count++ ，必须执行 setCount 函数，并传入最新的值</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  return (</span></span>
<span class="line"><span>    &lt;div&gt;</span></span>
<span class="line"><span>      &lt;button onClick={increase}&gt;{count}&lt;/button&gt;</span></span>
<span class="line"><span>      &lt;p onClick={addTodoHandler}&gt;todo input&lt;/p&gt;</span></span>
<span class="line"><span>    &lt;/div&gt;</span></span>
<span class="line"><span>  )</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>export default TodoInput</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React useState 还是很好理解的，语义非常明确。对于入门者，比 Vue3 ref 要简单多了。</p><h3 id="附-react-也有-ref" tabindex="-1"><a class="header-anchor" href="#附-react-也有-ref"><span>（附：React 也有 ref）</span></a></h3><p>上文说了 Vue3 ref 需要写 .value 比较麻烦。 其实 React 也有 ref 也需要写类似的 .current 才能获取和修改数据，这是 ref 的设计决定的写法。 （所以上文我不建议 Vue3 ref 语法糖去掉 .value，因为这会让大家忽略掉 ref 的本质） React ref 也有类似的问题，但 React ref 主要用于获取 DOM 节点或者其他组件节点，一般不常用。 而且 React ref 不具备 setXxx 能力，无法触发组件更新，这和 state 有本质区别，不会混淆。 所以 React 对于 ref 和 state 的设计是有明显的定位区别的，两者各司其职。 PS：其实 Vue3 ref 也可以获取 DOM 节点 —— 乱了吧……</p><h3 id="对象和数组" tabindex="-1"><a class="header-anchor" href="#对象和数组"><span>对象和数组</span></a></h3><p>Vue2 data() 也很简单清晰，但因为内部使用 defineProperty 可能会导致如下问题（所以 Vue3 使用 Proxy 实现响应式）</p><ul><li>对象层次较深时，可能会有性能问题，因为要一次性递归绑定响应式</li><li>修改数组只能用 API ，不能直接赋值某个 index</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码export default  {</span></span>
<span class="line"><span>    data() {</span></span>
<span class="line"><span>        return {</span></span>
<span class="line"><span>            user: { name: &#39;双越老师&#39; },</span></span>
<span class="line"><span>            city: [&#39;北京&#39;, &#39;深圳&#39;]</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Vue3 刚发布的时候，推荐使用 reactive 来做对象的响应式监听，后来大家发现 ref 也可以监听对象，于是激起了很多讨论。 现在看文档 Vue3 推荐统一使用 ref ，无论是值类型、对象还是数组。当然，又得用 .value 了。 并且在文档中总结了 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcn.vuejs.org%2Fguide%2Fessentials%2Freactivity-fundamentals.html%23limitations-of-reactive" target="_blank" rel="noopener noreferrer">reactive 的局限性</a> 。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码// 来自 Vue 官网 https://cn.vuejs.org/guide/essentials/reactivity-fundamentals.html#deep-reactivity</span></span>
<span class="line"><span>import { ref } from &#39;vue&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const obj = ref({</span></span>
<span class="line"><span>  nested: { count: 0 },</span></span>
<span class="line"><span>  arr: [&#39;foo&#39;, &#39;bar&#39;]</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function mutateDeeply() {</span></span>
<span class="line"><span>  // 以下都会按照期望工作</span></span>
<span class="line"><span>  obj.value.nested.count++</span></span>
<span class="line"><span>  obj.value.arr.push(&#39;baz&#39;)</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果你用过 Vue3 你应该体会到过这种纠结，如果你还没用过，你从这段描述应该也能感受到这种挣扎。这其实还是“也可以”的问题：用 A 也行，用 B 也行，A B 好像各有优劣，就选择困难症了…… 再看 React ，很统一，无论是处理值类型，还是数组、对象，都是通过 useState 定义，都是通过 setXxx 设置新数据。没有第二个选择，没有“也可以”。 【实战】把你代码 src/App.js 改为如下代码，刷新页面，点击 todo inpupt 文字即可看到效果。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>jsx</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码// src/App.js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>import { useState } from &#39;react&#39;</span></span>
<span class="line"><span>import TodoInput from &#39;./components/TodoInput&#39;</span></span>
<span class="line"><span>import TodoList from &#39;./components/TodoList&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function App() {</span></span>
<span class="line"><span>  const [list, setList] = useState([</span></span>
<span class="line"><span>    { id: 1, text: &#39;todo 1&#39; },</span></span>
<span class="line"><span>    { id: 2, text: &#39;todo 2&#39; },</span></span>
<span class="line"><span>  ])</span></span>
<span class="line"><span>  function addTodo(t) {</span></span>
<span class="line"><span>    const newTodo = { id: list.length + 1, text: t }</span></span>
<span class="line"><span>    setList([...list, newTodo]) //【注意】这里不能直接修改 list 而是要调用 setList</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  return (</span></span>
<span class="line"><span>    &lt;div&gt;</span></span>
<span class="line"><span>      &lt;TodoInput addTodo={addTodo} /&gt;</span></span>
<span class="line"><span>      {list.length &gt; 0 &amp;&amp; &lt;TodoList foo=&quot;hello foo&quot; list={list} /&gt;}</span></span>
<span class="line"><span>    &lt;/div&gt;</span></span>
<span class="line"><span>  )</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>export default App</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>唯一需要注意的是：不能直接修改 list 而是要调用 setList 函数，并传入新数据。使用 ES 结构语法 ...xxx 能非常轻松的生成新数据，例如：</p><ul><li>修改数组，一般会用 setList( [...list, newItem] )</li><li>修改对象，一把会用 setObj( { ...obj, newItem } )</li></ul><p>React useState 能定义并修改任何数据类型，而且没有 Vue3 refreactive “都可以”的心智负担，简单。</p><h3 id="数据的复杂性" tabindex="-1"><a class="header-anchor" href="#数据的复杂性"><span>数据的复杂性</span></a></h3><p>无论 Vue2 Vue3 为了实现数据响应式，它都需要把数据包裹一层，即你定义的数据并不是真正的数据。 这个在 Vue2 中并不明显，但在 Vue3 setup script 中 JS 操作较多的话，就会遇到这种问题。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码const raw = {}</span></span>
<span class="line"><span>const proxy = reactive(raw)</span></span>
<span class="line"><span>console.log(proxy === raw) // false 代理对象和原始对象不是全等的</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>而且，Vue3 的 ref 和 reactive 两种响应式的类型也不一样，为此 Vue 设计了很多 <a href="https://link.juejin.cn?target=https%3A%2F%2Fcn.vuejs.org%2Fapi%2F" target="_blank" rel="noopener noreferrer">API</a> 来进行各种数据类型的判断和转换，例如 isRefisReactivetoReftoRawtoValue 还有，为了满足非深度监听，Vue 还设计了各种 shallowXxx API 很多，得自己慢慢看<a href="https://link.juejin.cn?target=https%3A%2F%2Fcn.vuejs.org%2Fapi%2F" target="_blank" rel="noopener noreferrer">文档</a>。 反观 React 它的 state 就是你传入的数据，所见即所得，不需要任何 API 不需要任何说明。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码const infoRaw = { name: &#39;双越老师&#39; }</span></span>
<span class="line"><span>const [info, setInfo] = useState(infoRaw)</span></span>
<span class="line"><span>console.log(info === infoRaw)  // true</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>两者相比，哪个更简单呢？</p><h2 id="副作用和组件生命周期" tabindex="-1"><a class="header-anchor" href="#副作用和组件生命周期"><span>副作用和组件生命周期</span></a></h2><p>组件生命周期，你应该非常熟悉了，Vue 最基础的知识点，也是常考面试题。 说道“副作用”，没接触过 React 的同学可能会比较陌生，我们先简单介绍一下它。放心，它很好理解，一不小心就学会了。</p><h3 id="附-纯函数和副作用" tabindex="-1"><a class="header-anchor" href="#附-纯函数和副作用"><span>（附：纯函数和副作用）</span></a></h3><p>副作用，生活中最常看到的是在药品说明书中，例如某个 Z 药“副作用不详”。 副作用就是药品治疗过程中，产生了预期之外的影响。大部分是坏的，但有些也是好的，例如当年某治疗低血压的药竟意外成了男人们的福利，这也是副作用导致的。 对于编程开发中，有一种编程范式（方式）叫做函数式编程，其中有一个 <strong>纯函数</strong> 的概念。 意思就是：设计好输入和输出，你只管做这个计算，不要产生任何其他的影响（副作用），要纯粹。 例如，要计算 1+1=2 加法运算， 写一个纯函数就是。你看，只管计算，没做任何其他事情。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码function add (a, b) { return a + b }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>相反，你如果做运算的同时，又干了本职工作之外的事情，例如修改网页标题 —— 这你就不纯了，你脏了！</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码function add (a, b) {</span></span>
<span class="line"><span>    document.title = &#39;加法运算&#39; // 副作用（这样写不好）</span></span>
<span class="line"><span>    return a + b</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React 使用函数式组件，函数接收 props 返回 JSX （这其实和 1+1 返回 2 本质是一样的） ，按理说应该也是个纯函数。 但你作为一个 UI 组件，不能光考虑一次性的输出 JSX ，你还得考虑组件完整的生命周期，如更新、销毁。而这些都可以通过副作用来实现。（副作用有些是坏的，有些是好的，这里就是好的）</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>jsx</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码function App(props) {</span></span>
<span class="line"><span>    // 组件渲染完成，如何进行 Ajax 请求？ </span></span>
<span class="line"><span>    // 如何监听组件更新</span></span>
<span class="line"><span>    // 如何监听组件销毁</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return &lt;p&gt;App page&lt;/p&gt;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>你如果能看到这里，且没有疑问，那你接下来去学习 React 副作用应该毫无障碍。</p><h3 id="初次渲染" tabindex="-1"><a class="header-anchor" href="#初次渲染"><span>初次渲染</span></a></h3><p>Vue 对应的生命周期 beforeCreatecreatedbeforeMountMounted 大家应该都很熟悉了。 Vue3 composition API 做了一些 API 改动，如 onMounted 写法，但语义是一样的。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码import { ref, onMounted } from &#39;vue&#39;</span></span>
<span class="line"><span>const el = ref(0)</span></span>
<span class="line"><span>onMounted(() =&gt; { el.value = 10 })</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React 使用 useEffect 来处理副作用，当然也包括组件初次渲染相关的。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码import { useEffect } from &#39;react&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function App(props) {</span></span>
<span class="line"><span>    function fn() { console.log(&#39;发起 ajax 请求&#39;) }</span></span>
<span class="line"><span>    useEffect(fn)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return &lt;p&gt;App page&lt;/p&gt;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>useEffect 语义就是要执行一个副作用，即组件函数执行完以后，还要做点啥？ —— 在 fn 函数定义即可。 所以，你可以不用把 useEffect 和 Vue 组件生命周期做对比，你就按照“副作用”的概念来理解它，反而更容易。 【实战】在你的 src/App.js 中增加如下代码 <img src="https://cdn.nlark.com/yuque/0/2024/webp/28199172/1719452106975-4b23a21e-bd0d-49bb-878f-b5a331767b30.webp#averageHue=%23272221&amp;clientId=u0044065a-f65d-4&amp;from=paste&amp;id=uaa5c05bd&amp;originHeight=392&amp;originWidth=1586&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u09f06e8b-e916-48a6-a668-04e3585d96c&amp;title=" alt="" loading="lazy"> PS：修改网页标题其实可以在 public/index.html 中修改，这里只是为了练习 useEffect</p><h3 id="组件更新" tabindex="-1"><a class="header-anchor" href="#组件更新"><span>组件更新</span></a></h3><p>Vue 组件更新的生命周期是 beforeUpdate 和 updated ，Vue3 Composition API 有写法上的改变，但语义是相同的。 React 依然使用 useEffect 副作用处理组件更新的情况。React 擅长统一和抽象概念，体现设计思维。 useEffect 其实有两个参数：</p><ul><li>第一个参数是函数，即副作用要执行的具体内容，必填</li><li>第二个参数是依赖项数组，选填。</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码const [page, setPage] = useState(0)</span></span>
<span class="line"><span>const [keyword, setKeyword] = useState(&#39;&#39;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>useEffect(() =&gt; {</span></span>
<span class="line"><span>    fn(page, keyword)</span></span>
<span class="line"><span>}, [page, keyword])</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如上代码，useEffect 第二个参数（依赖项）是 [page, keyword] ，那它的副作用执行时机就是两个</p><ul><li>组件初次渲染完成，执行副作用</li><li>page 或 keyword 有变化，也会执行副作用</li></ul><p>【实战】在你的代码中新建 src/components/EffectTest.js 文件，并写入以下代码</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码import { useState, useEffect } from &#39;react&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function App(props) {</span></span>
<span class="line"><span>    const [page, setPage] = useState(0)</span></span>
<span class="line"><span>    const [keyword, setKeyword] = useState(&#39;&#39;)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    function fn(page, keyword) { console.log(&#39;发起 ajax 请求&#39;, page, keyword) }</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    // 1. 组件渲染完成触发； 2. page 或 keyword 变化时触发</span></span>
<span class="line"><span>    useEffect(() =&gt; {</span></span>
<span class="line"><span>        fn(page, keyword)</span></span>
<span class="line"><span>    }, [page, keyword]) </span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return &lt;div&gt;</span></span>
<span class="line"><span>        &lt;button onClick={() =&gt; setPage(page + 1)}&gt;setPage&lt;/button&gt;</span></span>
<span class="line"><span>        &lt;button onClick={() =&gt; setKeyword(keyword + &#39;x&#39;)}&gt;setKeyword&lt;/button&gt;</span></span>
<span class="line"><span>        &lt;p&gt;App page&lt;/p&gt;</span></span>
<span class="line"><span>    &lt;/div&gt;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>【实战】在 src/App.js 中引入 <!----> 组件，然后刷新浏览器控制台看打印效果。 PS：如果你发现初次渲染完成时，控制台打印两次 —— 你发现了一个小秘密，欢迎给我留言评论。 所以，不要把 useEffect 对比组件生命周期，用“副作用”概念去理解它。它可以在组件渲染完成后执行副作用，也可以监听某些 state 变化后执行副作用 —— 就这两条，即可为满足所有开发需求。</p><h3 id="组件销毁" tabindex="-1"><a class="header-anchor" href="#组件销毁"><span>组件销毁</span></a></h3><p>Vue 使用 beforeDestroy 和 Desctroyed 两个生命周期，很好理解。 React 依然使用 useEffect ，只不过需要你记住一件事儿：useEffect 函数里面，可以再 return 一个函数，用于监听组件销毁。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>js</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码useEffect(() =&gt; {</span></span>
<span class="line"><span>    // xxx</span></span>
<span class="line"><span>    </span></span>
<span class="line"><span>    return () =&gt; { console.log(&#39;组件销毁之前，如解绑自定义事件&#39;) }</span></span>
<span class="line"><span>})</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里是唯独需要记忆的地方，当然记不住上网一查也很简单。总的来说比 Vue 查阅文档的体量要少多了。 PS：其实这里还有很多可以深挖的（并不是表面上的“组件销毁”时机），不过本文是入门教程，暂且不说了，其他机会再分享吧。</p><h3 id="watch-computed" tabindex="-1"><a class="header-anchor" href="#watch-computed"><span>watch computed</span></a></h3><p>Vue watch 监听某个数据，React useEffct 即可实现，上文已讲。 Vue computed 计算数据，如何在 React 中实现呢？分两种情况。 第一，不用缓存计算结果（其实绝大部分情况都不用缓存，JS 计算是非常快的，很少遇到性能瓶颈），那直接写就行，没有任何障碍。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>jsx</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码const [count, setCount] = useState(0)</span></span>
<span class="line"><span>const doubleCount = count * 2 // 直接计算，满足绝大部分情况</span></span>
<span class="line"><span></span></span>
<span class="line"><span>return &lt;div&gt;</span></span>
<span class="line"><span>    &lt;button onClick={() =&gt; setCount(count + 1)}&gt;increase&lt;/button&gt;</span></span>
<span class="line"><span>    &lt;span&gt;{count}  {doubleCount}&lt;/span&gt;</span></span>
<span class="line"><span>&lt;/div&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>第二，需要缓存计算结果（少数情况），你可以使用 useMemo 做缓存。如下代码，只要 count 不变，doubleCount 就不会重新计算。这和 Vue computed 一样。 <img src="https://cdn.nlark.com/yuque/0/2024/webp/28199172/1719452107355-6bbc897e-cafb-4c79-83e9-d1578944ad8e.webp#averageHue=%23653b2d&amp;clientId=u0044065a-f65d-4&amp;from=paste&amp;id=ua09df895&amp;originHeight=264&amp;originWidth=1662&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=ud7dd87d6-3931-45d1-8b6a-fdf099385e8&amp;title=" alt="" loading="lazy"> 虽然前端面试动不动就问性能优化，其实大部分情况下不需要做 JS 计算层面的性能优化，所以无论是 Vue computed 还是 React useMemo 都用的不多。 从使用和语义来讲，这两者都很简单，很好理解。</p><h2 id="表单" tabindex="-1"><a class="header-anchor" href="#表单"><span>表单</span></a></h2><p>Vue 使用 v-model 双向绑定表单项的值，这在用户体验方面感觉非常棒，非常方便。<strong>单从 v-model 的开发体验上，Vue 是胜过 React 的。</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>html</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码&lt;p&gt;Message is: {{ message }}&lt;/p&gt;</span></span>
<span class="line"><span>&lt;input v-model=&quot;message&quot; placeholder=&quot;请输入...&quot; /&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>React 推荐使用<strong>受控组件</strong>（需要记住这个词）来处理表单项的值，其实也并不难理解。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>jsx</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码const [text, setText] = useState(&#39;&#39;)</span></span>
<span class="line"><span>function handleChangeText(event) {</span></span>
<span class="line"><span>    setText(event.target.value)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>return &lt;div&gt;</span></span>
<span class="line"><span>    &lt;input value={text} onChange={handleChangeText}/&gt;</span></span>
<span class="line"><span>&lt;/div&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>看以上代码，一共也没几行代码，也很好理解：定义 text 然后在 input change 时 setText 其实就是自己实现了一套 Vue v-model ，功能是很相似的。 那么 React 为何要让开发者自己写呢，它内置一个 v-model 不好吗？ —— 不好。 因为 React 在设计上不是“双向绑定”，而是“单项数据流”。所以 React 要让你自己写。 这就像上文 React 修改 state 要让你显示调用 setXxx 是一个道理。 如果替用户做的过多了，看似是功能全面了，但很有可能会导致设计混乱，理解起来更费劲。 代码多写几行少写几行这都没关系，代码的可读性，设计上的统一性，这些更重要。 【实战】把你代码的 src/components/TodoInput.js 改为如下内容，浏览器刷新测试。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>jsx</span></span>
<span class="line"><span></span></span>
<span class="line"><span>复制代码import { useState } from &#39;react&#39;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function TodoInput(props) {</span></span>
<span class="line"><span>  const { addTodo } = props</span></span>
<span class="line"><span>  function addTodoHandler() {</span></span>
<span class="line"><span>    addTodo(text)</span></span>
<span class="line"><span>    setText(&#39;&#39;)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  const [text, setText] = useState(&#39;&#39;)</span></span>
<span class="line"><span>  function handleChangeText(event) {</span></span>
<span class="line"><span>    setText(event.target.value)</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>  return (</span></span>
<span class="line"><span>    &lt;div&gt;</span></span>
<span class="line"><span>      &lt;input value={text} onChange={handleChangeText} /&gt; {/* 受控组件 */}</span></span>
<span class="line"><span>      &lt;button onClick={addTodoHandler}&gt;todo input&lt;/button&gt;</span></span>
<span class="line"><span>    &lt;/div&gt;</span></span>
<span class="line"><span>  )</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>export default TodoInput</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Vue v-model 和 React <strong>受控组件</strong>，前者更方便。但 React 受控组件也仅仅是多写几行代码，并没有其他心智负担。所以 Vue 也仅仅是在使用上更方便一点。</p><h2 id="开发-todo-list-项目" tabindex="-1"><a class="header-anchor" href="#开发-todo-list-项目"><span>开发 todo-list 项目</span></a></h2><p>有了以上的基础技能，我们就可以轻松的开发出一个 React todo-list 项目。 <img src="https://cdn.nlark.com/yuque/0/2024/webp/28199172/1719452107454-e71598b2-9147-4549-946b-36c541b96685.webp#averageHue=%23f6f6f6&amp;clientId=u0044065a-f65d-4&amp;from=paste&amp;id=udcb867c5&amp;originHeight=490&amp;originWidth=1642&amp;originalType=url&amp;ratio=2&amp;rotation=0&amp;showTitle=false&amp;status=done&amp;style=none&amp;taskId=u1903cf04-f8ff-451c-9594-8f586601b9e&amp;title=" alt="" loading="lazy"> 项目源码在 <a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fwangfupeng1988%2Freact-todo" target="_blank" rel="noopener noreferrer">github.com/wangfupeng1…</a></p><h2 id="react-很简单" tabindex="-1"><a class="header-anchor" href="#react-很简单"><span>React 很简单</span></a></h2><p>总结一下本文讲的几个重要方面，React 设计的很简洁。</p><ul><li>React 组件就是 JS 函数，简单</li><li>React 组件的属性，就是函数参数，简单</li><li>React 组件的事件，也是函数参数，执行事件就是执行 JS 函数，简单</li><li>JSX 的插值、属性、事件和样式，规则很少，更简洁</li><li>JSX 判断和循环完全使用 JS 语法，简单</li><li>React useState 语义明确，没有心智负担，简单</li><li>React state 就是原始数据，没有任何包裹处理，简单</li><li>React useEffect 涵盖所有副作用操作，API 更简洁</li><li>React 表单受控组件比 Vue v-model 会多写几行代码，但也没有其他心智负担</li></ul><p>你熟悉组件化开发，熟悉 JS，熟悉 Vue，你还能说出 Vue 数据响应式的原理，甚至还看过 Vue 的源码。 就这水平，学会 React 是分分钟的事情。</p><h2 id="" tabindex="-1"><a class="header-anchor" href="#"><span></span></a></h2><p>作者：前端双越老师 链接：<a href="https://juejin.cn/post/7344536653463207973" target="_blank" rel="noopener noreferrer">https://juejin.cn/post/7344536653463207973</a> 来源：稀土掘金 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></div><!----><footer class="vp-page-meta"><div class="vp-meta-item edit-link"><a class="auto-link external-link vp-meta-label" href="https://github.com/an31742/edit/main/src/businessProblem/新知识/【长文】只会 Vue 不会 React ？22 点证明 React 比 Vue3 更简单.md" aria-label="在 GitHub 上编辑此页" rel="noopener noreferrer" target="_blank"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewBox="0 0 1024 1024" fill="currentColor" aria-label="edit icon" name="edit"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></svg><!--]-->在 GitHub 上编辑此页<!----></a></div><div class="vp-meta-item git-info"><div class="update-time"><span class="vp-meta-label">上次编辑于: </span><!----></div><div class="contributors"><span class="vp-meta-label">贡献者: </span><!--[--><!--[--><span class="vp-meta-info" title="email: 2234170284@qq.com">an31742</span><!--]--><!--]--></div></div></footer><nav class="vp-page-nav"><a class="route-link auto-link prev" href="/businessProblem/%E6%96%B0%E7%9F%A5%E8%AF%86/%E5%BE%AE%E5%89%8D%E7%AB%AF-qiankun.html" aria-label="微前端-qiankun"><div class="hint"><span class="arrow start"></span>上一页</div><div class="link"><span class="font-icon icon fa-fw fa-sm fas fa-circle-info" style=""></span>微前端-qiankun</div></a><!----></nav><div id="vp-comment" class="giscus-wrapper input-top" style="display:block;"><svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" preserveAspectRatio="xMidYMid" viewBox="0 0 100 100"><circle cx="28" cy="75" r="11" fill="currentColor"><animate attributeName="fill-opacity" begin="0s" dur="1s" keyTimes="0;0.2;1" repeatCount="indefinite" values="0;1;1"></animate></circle><path fill="none" stroke="#88baf0" stroke-width="10" d="M28 47a28 28 0 0 1 28 28"><animate attributeName="stroke-opacity" begin="0.1s" dur="1s" keyTimes="0;0.2;1" repeatCount="indefinite" values="0;1;1"></animate></path><path fill="none" stroke="#88baf0" stroke-width="10" d="M28 25a50 50 0 0 1 50 50"><animate attributeName="stroke-opacity" begin="0.2s" dur="1s" keyTimes="0;0.2;1" repeatCount="indefinite" values="0;1;1"></animate></path></svg></div><!----><!--]--></main><!--]--><footer class="vp-footer-wrapper"><div class="vp-footer">默认页脚</div><div class="vp-copyright">Copyright © 2025 小安 </div></footer></div><!--]--><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/assets/app-HeVUa9bp.js" defer></script>
  </body>
</html>
