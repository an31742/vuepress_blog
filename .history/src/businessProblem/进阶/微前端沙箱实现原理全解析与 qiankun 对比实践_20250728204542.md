----

# **ᵀ 本质透视镜**
**本质是：浏览器环境中实现子应用运行隔离与通信的控制容器**。

---

## **ᴼ 关系拓扑图**
```plain
[子应用 JS] →[沙箱 Proxy] → 控制访问 window  
[子应用 CSS] →[样式作用域封装] → 避免污染主应用  
[事件/通信] →[安全信道 postMessage] → 实现主子通信
```

---

## **ᴿ 行动意义键点**
  


**核心价值是：实现多子应用的安全托管与独立运行**。

+ 避免全局污染 / 犯规访问 / 内存泄漏
+ 支持 iframe / 非 iframe 切换
+ 容易集成权限、性能监控

---

## **ᴾ 步骤拆解器**
### **1. JS 隔离：Proxy + with**
```plain
const fakeWindow = Object.create(null)
const proxy = new Proxy(window, {
  get(target, key) {
    if (key in fakeWindow) return fakeWindow[key]
    return Reflect.get(target, key)
  },
  set(target, key, value) {
    fakeWindow[key] = value
    return true
  }
})
```

<font style="color:#0e0e0e;">将子应用 JS 以 </font><font style="color:#0e0e0e;">with(proxy)</font><font style="color:#0e0e0e;"> 扩展域执行。</font>

---

### **2. CSS 样式隔离：Scoped CSS**
```plain
<div id="micro-app1">
  <style scoped>
    .btn { color: red; }
  </style>
</div>
```

<font style="color:#0e0e0e;">或者后缀处理样式选择器实现样式沙箱化</font>

---

### **3. 生命周期钩子**
```plain
export async function loadApp(url: string) {
  const html = await fetch(url).then(res => res.text())
  const { mount, unmount } = parseHtmlAndExtractLifecycle(html)
  mount(proxy)
}
```

---

### **4. 主子通信：postMessage**
```plain
// 主应用
window.addEventListener('message', e => {
  if (e.data.from === 'subApp') console.log(e.data.payload)
})

// 子应用
window.parent.postMessage({ from: 'subApp', payload: { count: 1 } }, '*')
```

---

### **5. 子应用加载 + 资源隔离**
```plain
const script = document.createElement('script')
script.src = 'https://sub-app.com/main.js'
sandboxContainer.appendChild(script)
```

<font style="color:#0e0e0e;">配合 CSP + 禁止 eval 等措施增强安全性</font>

---

## **对比分析表**
| **特性** | **手写沙箱** | **qiankun** |
| --- | --- | --- |
| JS 隔离 | ✅ Proxy + with | ✅ snapshot 沙箱 |
| CSS 隔离 | ✅ scoped/后缀处理 | ✅ strict style 加强模式 |
| 生命周期 | ✅ mount/unmount | ✅ bootstrap/mount 完备 |
| DOM 隔离 | ✅ 定制容器执行 | ✅ 默认 DOM 容器 |
| 通信 | ✅ postMessage/custom | ✅ useGlobalState |
| iframe 支持 | ✅ iframe 切换 | ❌ 默认不支持 |
| 学习成本 | 高，自定义强 | 低，一行代码连接 |
| 性能/灵活性 | ✅ 可控，轻量化 | ❌ 内部处理较重 |


---

## **实际项目搭配**
```plain
📁 main-app/
  ├─ micro-loader.ts       // 子应用加载器
  ├─ sandbox.ts            // 沙箱实现
  ├─ messaging.ts          // 主子通信
  └─ views/
      └─ AppContainer.vue  // 子应用容器

📁 sub-app/
  └─ expose.ts             // 生命周期折择点 mount/unmount
```

---

## **结语**
<font style="color:#0e0e0e;">手写沙箱不是为了替代 qiankun，而是为了更好理解“微前端”的本质</font>



+ 沙箱是解决应用分正与安全隔离的核心技术
+ qiankun 是构建微前端平台的优秀工程化框架
+ 为特殊场景或小型项目推荐自定义沙箱



```html
<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="UTF-8" />
    <title>微前端沙箱演示</title>
    <style>
      body {
        font-family: sans-serif;
        padding: 20px;
      }

      .app-container {
        border: 1px solid #ccc;
        margin-bottom: 20px;
        padding: 10px;
      }

      .micro-app-a h2 {
        color: red;
      }

      .micro-app-b h2 {
        color: green;
      }

      button {
        margin: 4px;
      }
    </style>
  </head>
  <body>
    <h1>主应用</h1>

    <div>
      <button onclick="mountApp('A')">挂载子应用 A</button>
      <button onclick="unmountApp('A')">卸载子应用 A</button>

      <button onclick="mountApp('B')">挂载子应用 B</button>
      <button onclick="unmountApp('B')">卸载子应用 B</button>
    </div>

    <div id="app-A" class="app-container"></div>
    <div id="app-B" class="app-container"></div>

    <script>
      // ==== 1️⃣ 沙箱类 ====
      class MicroSandbox {
        constructor(name) {
          this.name = name
          this.fakeWindow = {}
          this.active = false

          const self = this

          this.proxy = new Proxy(window, {
            get(target, key) {
              return self.active ? (key in self.fakeWindow ? self.fakeWindow[key] : target[key]) : target[key]
            },
            set(target, key, value) {
              if (self.active) {
                self.fakeWindow[key] = value
              } else {
                target[key] = value
              }
              return true
            },
            has(target, key) {
              return key in self.fakeWindow || key in target
            },
          })
        }

        start() {
          this.active = true
          console.log(`[沙箱:${this.name}] 启动`)
        }

        stop() {
          this.active = false
          this.fakeWindow = {}
          console.log(`[沙箱:${this.name}] 停止`)
        }

        getProxy() {
          return this.proxy
        }
      }

      // ==== 2️⃣ 样式作用域封装 ====
      function scopeCSS(cssText, scopeClass) {
        return cssText.replace(/([^\r\n,{}]+)(,(?=[^}]*{)|\s*{)/g, (match, selector, brace) => {
          if (selector.includes(`.${scopeClass}`)) return match
          return `.${scopeClass} ${selector}${brace}`
        })
      }

      // ==== 3️⃣ 子应用定义 ====
      const microApps = {
        A: {
          container: "app-A",
          class: "micro-app-a",
          html: `<div><h2>我是子应用 A</h2><p>testGlobal = <span id="val-A"></span></p></div>`,
          style: `h2 { font-size: 22px; }`,
          script: `
          proxy.testGlobal = "A123"
          document.getElementById("val-A").innerText = proxy.testGlobal
        `,
        },
        B: {
          container: "app-B",
          class: "micro-app-b",
          html: `<div><h2>我是子应用 B</h2><p>testGlobal = <span id="val-B"></span></p></div>`,
          style: `h2 { font-size: 18px; }`,
          script: `
          proxy.testGlobal = "B456"
          document.getElementById("val-B").innerText = proxy.testGlobal
        `,
        },
      }

      const sandboxes = {}

      // ==== 4️⃣ 挂载函数 ====
      function mountApp(name) {
        const app = microApps[name]
        const container = document.getElementById(app.container)

        if (!sandboxes[name]) {
          sandboxes[name] = new MicroSandbox(name)
        }

        const sandbox = sandboxes[name]
        sandbox.start()
        const proxy = sandbox.getProxy()

        container.className = `app-container ${app.class}`
        container.innerHTML = app.html

        // 动态插入 scoped style
        const scopedStyle = scopeCSS(app.style, app.class)
        const styleEl = document.createElement("style")
        styleEl.textContent = scopedStyle
        container.appendChild(styleEl)

        // 用 proxy 作为沙箱环境执行代码
        const scriptFn = new Function("proxy", app.script)
        scriptFn(proxy)
      }

      // ==== 5️⃣ 卸载函数 ====
      function unmountApp(name) {
        const app = microApps[name]
        const container = document.getElementById(app.container)
        container.innerHTML = ""
        if (sandboxes[name]) sandboxes[name].stop()
      }
    </script>
  </body>
</html>

```

