---
title: 闭包
icon: object-group
tag:
  - 面试必考
---

### 闭包（Closure）详解

#### 1. **核心定义**  
闭包是**函数与其词法环境的组合**，它能访问并记忆自身作用域外的变量，即使外层函数已执行完毕。本质是作用域链的延伸。

#### 2. **形成条件**  
```javascript
function outer() {
  const secret = "confidential"; // 被闭包"捕获"的变量
  
  return function inner() {      // 闭包函数
    console.log(secret);         // 访问外部作用域变量
  };
}

const closure = outer();         // outer执行完毕
closure();                       // 输出"confidential" ✅
```
- ✅ 函数嵌套（inner 在 outer 内定义）  
- ✅ 内部函数引用外部变量（`secret`）  
- ✅ 内部函数被导出（返回/传递给其他作用域）

#### 3. **关键特性**
1. **变量持久化**  
   被引用的外层变量不会被GC回收，常驻内存
   ```javascript
   function counter() {
     let count = 0;
     return () => count++; // 每次调用闭包都修改同一个count
   }
   const inc = counter();
   inc(); // 1
   inc(); // 2 ✅ 状态被保留
   ```

2. **私有性封装**  
   模拟私有变量（ES6前主流方案）
   ```javascript
   const module = (() => {
     const privateVar = "hidden";
     
     return {
       getVar: () => privateVar,
       setVar: (v) => privateVar = v
     };
   })();

   console.log(module.privateVar); // undefined ❌
   console.log(module.getVar());   // "hidden" ✅
   ```

#### 4. **内存泄漏风险与解决方案**  
```javascript
// 危险示例：DOM元素引用未释放
function init() {
  const bigData = new Array(1000000).fill("*");
  document.getElementById("btn").addEventListener("click", () => {
    console.log(bigData.length); // 闭包持有bigData
  });
}
```
**优化方案**：  
- 手动解除引用：`btn.removeEventListener()`  
- 使用弱引用：`WeakMap`/`WeakSet`  
- 事件委托：在父级监听事件  

#### 5. **应用场景**  
| 场景                | 示例                          | 优势                     |
|---------------------|-------------------------------|--------------------------|
| 模块模式            | IIFE + 返回公共API            | 封装私有变量             |
| 函数工厂            | 生成带配置的预置函数          | 减少重复参数传递         |
| 异步回调            | 事件处理器访问组件状态        | 维持上下文一致性         |
| 柯里化              | `add(1)(2)(3)`实现            | 参数分步传递             |
| 防抖/节流           | 维护`timer`变量               | 跨多次调用保持状态       |

#### 6. **面试考点扩展**
1. **作用域链机制**  
   ```javascript
   function createClosures() {
     const arr = [];
     for (var i = 0; i < 3; i++) { // 改用let修复
       arr.push(() => console.log(i));
     }
     return arr;
   }
   const funcs = createClosures();
   funcs[0](); // 输出3 ❌ (预期0)
   ```
   - **问题**：所有闭包共享同一个`i`（循环结束值为3）  
   - **解决**：用`let`创建块级作用域，或使用IIFE隔离

2. **内存分析工具**  
   - Chrome DevTools Memory面板  
   - `performance.memory` API监控堆使用

#### 7. **最佳实践**
1. **避免滥用**：非必要场景减少闭包使用  
2. **及时清理**：移除事件监听/置空引用  
3. **模块化替代**：优先使用ES6 Modules  
4. **性能敏感场景**：避免在循环中创建闭包  

> 闭包是JS函数式编程的核心机制，正确使用可实现状态封装、高阶函数等高级特性，但需警惕无意识的内存持有。