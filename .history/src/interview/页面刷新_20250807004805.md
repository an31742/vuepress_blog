---
title: 页面刷新
icon: object-group
tag:
  - 面试必考
---

### 页面刷新
一、抖动刷新方案（视觉体验差）
这些方案会导致明显的视觉中断或布局跳动：
1. 整页强制刷新  
window.location.reload();
// 或
this.$router.go(0);
  ○ 抖动表现：整个页面闪白，所有资源重新加载
  ○ 场景：需要完全重置应用状态时
2. v-if 暴力切换  
<template>
  <div v-if="show">
    <!-- 内容区域 -->
  </div>
</template>

<script>
export default {
  methods: {
    refresh() {
      this.show = false;
      setTimeout(() => this.show = true, 50);
    }
  }
}
</script>

  ○ 抖动表现：内容区域短暂消失
  ○ 场景：简单组件重置
3. 路由跳转回退  
this.$router.push('/empty');
setTimeout(() => this.$router.go(-1), 100);
  ○ 抖动表现：页面短暂切换到空白页
  ○ 场景：需要重置路由状态
二、非抖动刷新方案（平滑体验）
这些方案保持视觉连续性，无感知刷新：
1. Router.replace 时间戳法  
refreshSilently() {
  const newQuery = {
    ...this.$route.query,
    _t: Date.now() // 添加时间戳参数
  };
  this.$router.replace({ query: newQuery });
}
  ○ 原理：改变路由查询参数强制组件更新
  ○ 优势：URL变化但页面无跳转感
  ○ 场景：数据更新后刷新视图
2. 动态 Key 重置组件  
<template>
  <UserProfile :key="componentKey"/>
</template>

<script>
export default {
  data() {
    return { componentKey: 0 }
  },
  methods: {
    resetComponent() {
      this.componentKey += 1; // 改变key重建组件
    }
  }
}
</script>

  ○ 原理：Vue 通过 key 变化销毁重建组件
  ○ 优势：可配合过渡动画实现平滑重置
  ○ 场景：需要完全重置组件状态
3. Keep-alive 缓存控制  
<template>
  <keep-alive :include="cachedViews">
    <router-view :key="keyWithTime"/>
  </keep-alive>
</template>

<script>
export default {
  computed: {
    keyWithTime() {
      return this.$route.path + this.refreshStamp;
    }
  },
  methods: {
    refreshView() {
      this.refreshStamp = Date.now();
    }
  }
}
</script>

  ○ 原理：修改 router-view 的 key 触发缓存更新
  ○ 优势：保留滚动位置和未变化组件状态
  ○ 场景：复杂页面局部刷新
4. 数据驱动局部更新  
async refreshData() {
  this.loading = true;
  try {
    const newData = await api.fetchData();
    this.list = [...newData]; // 通过数据引用变化驱动更新
  } finally {
    this.loading = false;
  }
}
  ○ 原理：响应式系统自动检测数据变化
  ○ 优势：最符合 Vue 设计哲学的方式
  ○ 场景：常规数据更新
三、方案对比矩阵
方案	抖动程度	状态保持	性能开销	实现复杂度	适用场景
整页刷新	严重抖动	❌	高	★☆☆	全局重置/退出登录
v-if 切换	明显抖动	❌	中	★★☆	简单组件重置
路由回跳	中等抖动	⚠️部分	中	★★★	特殊路由状态重置
Router.replace	无抖动	✅	低	★★☆	数据更新视图刷新
Key 重置	无抖动	❌	中	★☆☆	组件完全重置
Keep-alive	无抖动	✅	低	★★★	复杂页面局部更新
数据驱动	无抖动	✅	最低	★☆☆	常规数据变更
四、Router.replace 的核心优势

1. 组件复用：不会销毁组件实例
2. 状态保留：保留 data 和 Vuex 状态
3. 滚动保持：不会重置滚动位置
4. 无感刷新：无白屏或布局跳动
五、最佳实践推荐
1. 常规数据更新 → 纯数据驱动  
// 最优方案
this.userData = await fetchUser();
2. 需要重置查询参数 → Router.replace  
// 带过渡效果的无感刷新
this.$router.replace({
  query: { ...this.$route.query, refresh: Date.now() }
});
3. 需要完全重置组件 → Key 变更 + 动画  
<transition name="fade">
  <DataTable :key="tableKey" />
</transition>

<script>
export default {
  methods: {
    resetTable() {
      this.tableKey = Date.now();
    }
  }
}
</script>

<style>
.fade-enter-active {
  transition: opacity 0.3s;
}
.fade-enter {
  opacity: 0;
}
</style>

4. 复杂页面局部更新 → Keep-alive 控制  
// 配合事件总线
export default {
  mounted() {
    this.$eventBus.$on('refresh-section', this.refreshSection);
  },
  methods: {
    refreshSection() {
      this.sectionKey = Date.now();
    }
  }
}
六、需要避免的抖动模式
1. 连续同步操作：
// 错误：连续操作导致多次重绘
this.show = false;
this.show = true; // 浏览器可能合并但不可靠
2. 无过渡的组件切换：
<!-- 视觉突兀 -->
<ComponentA v-if="showA" />
<ComponentB v-else />
3. 异步操作未处理：
// 错误：可能出现在加载过程中
this.loading = true;
fetchData().then(data => {
  this.data = data;
  this.loading = false;
});
终极选择指南：
Router.replace 是解决无抖动刷新的首选方案，特别适用于：  
● 需要更新当前路由参数时  
● 保持组件状态和滚动位置  
● 实现无感知数据刷新
但当需要完全重置组件状态时，配合过渡动画的 Key 变更 方案更合适