---
title: 闭包
icon: object-group
tag:
  - 面试必考
---



### `ref` 与 `reactive` 深度对比解析  

---

#### 1. **核心设计差异**  
| **特性**         | `ref`                          | `reactive`                     |
|------------------|--------------------------------|--------------------------------|
| **数据类型**     | 基本类型 + 引用类型            | **仅限引用类型** (对象/数组)   |
| **包装方式**     | 创建 `{ value: T }` 包装对象   | 直接代理原始对象               |
| **访问方式**     | 需要 `.value` 访问/修改        | 直接访问属性                   |
| **TS类型**       | `Ref<T>`                       | `UnwrapNestedRefs<T>`          |

```typescript
// 类型定义示例
const count = ref(0);          // Ref<number>
const state = reactive({       // { count: number }
  count: 0
});
```

---

#### 2. **使用场景对比**  
**适合 `ref` 的场景**：  
1. 基本类型值 (`string`, `number`, `boolean`)  
   ```javascript
   const name = ref('Alice'); // ✅ 优于 reactive({ value: 'Alice' })
   ```
2. 需要保持引用稳定的独立值  
   ```javascript
   const timerId = ref(null); // 在逻辑中重置 timerId.value = null
   ```
3. 需要传递到组合函数  
   ```javascript
   // 组合函数
   const useCounter = () => {
     const count = ref(0);
     const increment = () => count.value++;
     return { count, increment }; // 解构后仍保持响应性
   }
   ```

**适合 `reactive` 的场景**：  
1. 关联数据组成的对象  
   ```javascript
   const user = reactive({
     name: 'Bob',
     age: 30,
     address: { city: 'New York' } // ✅ 嵌套对象自动解包
   });
   ```
2. 表单分组  
   ```javascript
   const form = reactive({
     username: '',
     password: '',
     remember: false
   });
   ```

---

#### 3. **响应式原理差异**  
| **行为**               | `ref`                                  | `reactive`                          |
|------------------------|----------------------------------------|-------------------------------------|
| **解包行为**           | 模板中自动解包 (无需 `.value`)         | 直接访问属性                        |
| **替换对象**           | 可直接赋值 (`ref.value = newObj`)      | 会**丢失响应性** (需 `Object.assign` 或工具函数) |
| **数组处理**           | 需通过 `.value` 操作                   | 直接操作 (`push/pop`)               |
| **原始对象保护**       | 不修改原对象                           | **代理对象 ≠ 原对象**               |

```javascript
// 替换对象陷阱
const state = reactive({ data: null });
state.data = { items: [] };     // ✅ 响应性保持

const objRef = ref({ items: [] });
objRef.value = { new: true };   // ✅ 响应性保持 (.value 赋值)

const reactiveObj = reactive({});
reactiveObj = { new: true };    // ❌ 报错！不可直接替换
```

---

#### 4. **解包行为对比**  
**模板中的自动解包**：  
```vue
<template>
  <!-- ref 自动解包 -->
  <div>{{ count }}</div>         <!-- 无需 .value -->
  
  <!-- reactive 直接访问 -->
  <div>{{ user.name }}</div>
</template>

<script setup>
const count = ref(0);           // 模板中自动解包
const user = reactive({ name: 'Eva' });
</script>
```

**响应式对象中的 ref 解包**：  
```javascript
const count = ref(0);
const state = reactive({
  count,          // 自动解包！访问 state.count 无需 .value
  double: computed(() => state.count * 2) // ✅ 直接使用
});
```

---

#### 5. **工具函数支持**  
| **API**          | `ref` 支持          | `reactive` 支持     |  
|------------------|---------------------|---------------------|  
| `isRef()`        | ✅ 检测 ref 对象    | ❌ 返回 false        |  
| `unref()`        | ✅ 返回 .value      | ❌ 返回原对象        |  
| `toRef()`        | ❌ 不必要           | ✅ 对象属性 → Ref    |  
| `toRefs()`       | ❌ 不必要           | ✅ 解构对象保持响应性 |  

```javascript
// 解构 reactive 对象的最佳实践
const state = reactive({ x: 1, y: 2 });
const { x, y } = toRefs(state); // 解构为 ref 变量

// 修改仍响应
x.value = 10;
console.log(state.x); // 10 ✅
```

---

#### 6. **性能与内存**  
| **指标**         | `ref`                          | `reactive`                     |  
|------------------|--------------------------------|--------------------------------|  
| **内存占用**     | 稍高（额外包装对象）            | 更低                           |  
| **访问速度**     | 需 .value 多一层访问            | 直接访问更快                    |  
| **创建开销**     | 极低                            | 对象越大初始化成本越高          |  

> 实测差异：在 10,000 次创建中，`ref` 比 `reactive` 快约 15%，但日常使用无感知差异

---

#### 7. **最佳实践总结**  
1. **黄金法则**：  
   - 基本类型 → `ref`  
   - 关联对象 → `reactive`  
   - 组合函数返回 → `ref` (便于解构)  

2. **代码风格**：  
   - 变量命名：`ref` 后缀加 `Ref` (如 `countRef`)，`reactive` 用自然命名  
   - 避免混用：同一数据源不要同时使用两种 API  

3. **解构策略**：  
   ```javascript
   // 推荐：reactive 对象用 toRefs 解构
   const { count, name } = toRefs(props);
   
   // 不推荐：直接解构 reactive 对象
   const { x, y } = state; // ❌ 失去响应性
   ```

4. **工具函数选择**：  
   ```javascript
   // 将对象属性转为 ref
   const ageRef = toRef(user, 'age');
   
   // 将整个对象转为 ref
   const userRef = ref({
     name: 'Tom',
     age: 28
   });
   ```

> **核心结论**：`ref` 是通用响应式单元，`reactive` 是对象聚合容器。理解其差异可写出更高效、可维护的 Vue3 代码。