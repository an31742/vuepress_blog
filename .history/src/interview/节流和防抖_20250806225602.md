---
title: 节流和防抖
icon: object-group
tag:
  - 面试必考
---

### 节流（Throttle）与防抖（Debounce）深度解析  
**核心目标**：优化高频事件处理，避免性能损耗（如滚动、输入、窗口缩放等）

---

#### 1. **核心概念对比**  
| **特性**       | 节流（Throttle）                  | 防抖（Debounce）                |
|----------------|-----------------------------------|---------------------------------|
| **本质**       | 固定时间间隔执行一次              | 事件停止触发后延迟执行          |
| **执行时机**   | 周期内首次/末次触发（可配置）     | 仅执行最后一次触发              |
| **类比**       | 水龙头匀速滴水（固定频率）        | 电梯等人（关门后启动）          |
| **适用场景**   | 滚动事件、射击游戏连发            | 搜索框输入联想、窗口resize      |

---

#### 2. **实现原理与代码**  
**防抖实现**（延迟执行末次操作）  
```javascript
function debounce(func, delay) {
  let timer = null;
  
  return (...args) => {
    clearTimeout(timer); // 取消前次延时
    timer = setTimeout(() => {
      func.apply(this, args); // 延迟执行
    }, delay);
  };
}

// 使用：输入停止500ms后执行搜索
const searchInput = document.getElementById('search');
searchInput.addEventListener('input', debounce(fetchResults, 500));
```
**关键点**：  
- 每次触发重置计时器  
- 仅保留最后一次调用  

**节流实现**（固定频率执行）  
```javascript
function throttle(func, interval) {
  let lastTime = 0;
  
  return (...args) => {
    const now = Date.now();
    if (now - lastTime >= interval) { 
      func.apply(this, args); // 达到间隔则执行
      lastTime = now; // 更新最后执行时间
    }
  };
}

// 使用：滚动时每200ms检查位置
window.addEventListener('scroll', throttle(checkPosition, 200));
```
**关键点**：  
- 通过时间戳控制执行间隔  
- 保证周期性执行  

---

#### 3. **高级模式实现**  
**支持首/尾双模式（Lodash风格）**  
```javascript
function advancedThrottle(func, delay, { leading = true, trailing = true }) {
  let lastExec = 0;
  let timer = null;

  return (...args) => {
    const now = Date.now();
    const remaining = delay - (now - lastExec);

    if (remaining <= 0) {
      if (timer) clearTimeout(timer);
      if (leading) func.apply(this, args); // 首执行
      lastExec = now;
    } else if (trailing && !timer) {
      timer = setTimeout(() => {
        func.apply(this, args); // 尾执行
        timer = null;
        lastExec = Date.now();
      }, remaining);
    }
  };
}

// 使用：首尾均执行（如按钮连续点击）
btn.onclick = advancedThrottle(submitForm, 1000, { leading: true, trailing: true });
```

---

#### 4. **性能对比与选型**  
| **场景**               | 推荐方案   | 原因                                                                 |
|------------------------|------------|----------------------------------------------------------------------|
| 搜索框输入联想         | 防抖       | 避免频繁请求，只在用户停止输入时触发                                 |
| 无限滚动加载           | 节流       | 周期性检查位置，避免滚动事件高频触发                                 |
| 窗口resize事件         | 防抖       | 调整结束后再计算布局，避免中间状态抖动                               |
| 游戏角色移动/射击      | 节流       | 保持固定操作频率，避免操作丢失或卡顿                                 |
| 按钮防重复提交         | 节流+防抖  | 立即响应首次点击（节流首执行），阻止短时重复提交（防抖）             |

---

#### 5. **常见问题与解决方案**  
1. **this指向丢失**  
   - 使用箭头函数 或 `func.apply(this)` 绑定上下文  
2. **参数传递问题**  
   - 通过闭包保存事件参数 `(...args) => {...}`  
3. **异步场景阻塞**  
   - 结合 `requestAnimationFrame`（动画场景）：  
     ```javascript
     const rafThrottle = fn => {
       let ticking = false;
       return () => {
         if (!ticking) {
           requestAnimationFrame(() => {
             fn();
             ticking = false;
           });
           ticking = true;
         }
       };
     };
     ```

---

#### 6. **最佳实践总结**  
1. **防抖适用**：  
   - 用户主动停止操作后只需响应最终状态（如输入验证、提交确认）  
2. **节流适用**：  
   - 需要保持操作连贯性（如拖拽、游戏控制）  
3. **混合策略**：  
   - 首执行节流 + 尾防抖（如页面滚动加载）  
4. **框架集成**：  
   - Vue：`v-debounce-click` 自定义指令  
   - React：`useDebounce`/`useThrottle` Hooks  
   ```javascript
   // React Hook示例
   const useDebounce = (value, delay) => {
     const [debouncedValue, setDebouncedValue] = useState(value);
     useEffect(() => {
       const handler = setTimeout(() => setDebouncedValue(value), delay);
       return () => clearTimeout(handler); // 清理副作用
     }, [value, delay]);
     return debouncedValue;
   };
   ```

> 关键原则：**高频事件必优化，防抖节流按需选；首尾执行可配置，内存泄漏要预防**