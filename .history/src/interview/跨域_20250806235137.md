---
title: 跨域
icon: object-group
tag:
  - 面试必考
---


核心原理
跨域由浏览器同源策略引发（协议/域名/端口任一不同即跨域）。解决本质是绕过策略限制或获取服务器授权。

主流解决方案对比
方案	适用场景	实现复杂度	安全性	协议要求
CORS	主流API调用	★★☆	高	需服务端配合
代理服务器	本地开发/无服务端控制权	★☆☆	中	无特殊要求
JSONP	老旧浏览器兼容	★☆☆	低	仅GET请求
WebSocket	实时双向通信	★★★	高	需协议升级
postMessage	跨窗口/iframe通信	★★☆	中	需控制子窗口
Nginx反向代理	生产环境部署	★★★	高	需服务器权限

一、服务端解决方案
1. CORS（跨域资源共享） - 首选方案
# 服务端响应头示例
Access-Control-Allow-Origin: https://yourdomain.com  # 或 * (不推荐)
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: Content-Type, Authorization
Access-Control-Allow-Credentials: true  # 允许携带cookie
Access-Control-Max-Age: 86400           # 预检缓存时间
关键流程：
1. 浏览器发送预检请求（OPTIONS）
2. 服务端响应允许的源/方法/头信息
3. 浏览器发送实际请求
4. 服务端返回带CORS头的响应
2. Nginx反向代理 - 生产环境推荐
# nginx.conf 配置示例
server {
    listen 80;
    server_name yourdomain.com;

    location /api/ {
        proxy_pass http://api-server:3000;  # 转发到目标服务器
        proxy_set_header Host $host;
        add_header 'Access-Control-Allow-Origin' '*' always;  # 添加CORS头
    }
}
● 优势：前端无感知，避免客户端修改

二、纯前端解决方案
1. 开发环境代理（Webpack/Vite）
// vite.config.js
export default {
  server: {
    proxy: {
      '/api': {
        target: 'http://target-server.com',
        changeOrigin: true,  // 修改请求头Host
        rewrite: path => path.replace(/^\/api/, '')
      }
    }
  }
}
● 请求 /api/users → 实际访问 http://target-server.com/users
2. JSONP - 仅限GET请求
function jsonp(url, callback) {
  const script = document.createElement('script');
  script.src = `${url}?callback=${callback.name}`;
  
  window[callback.name] = data => {
    document.body.removeChild(script);
    delete window[callback.name];
    callback(data);
  };
  
  document.body.appendChild(script);
}

// 使用示例
jsonp('http://api.com/data?q=test', handleResponse);
3. postMessage跨域通信
// 父窗口 (http://parent.com)
const iframe = document.getElementById('child-iframe');
iframe.contentWindow.postMessage('Hello', 'http://child.com');

// 子窗口 (http://child.com)
window.addEventListener('message', event => {
  if (event.origin !== 'http://parent.com') return;
  console.log('Received:', event.data);
});

三、高级协议方案
1. WebSocket跨域
// 客户端
const socket = new WebSocket('ws://cross-domain-server.com');

socket.onopen = () => {
  socket.send(JSON.stringify({ type: 'ping' }));
};

socket.onmessage = event => {
  console.log('Received:', event.data);
};
● 优势：不受同源策略限制（需服务端支持WS协议）
2. 跨域资源共享(CORS)的扩展应用
● 携带凭证：需设置 withCredentials: true + 服务端 Access-Control-Allow-Credentials: true
● 自定义头：预检请求需声明 Access-Control-Allow-Headers

四、特殊场景方案
1. document.domain降域（同父域）
// http://a.example.com 和 http://b.example.com
document.domain = 'example.com';  // 共享域
2. 跨域图片
<!-- 不受同源策略限制 -->
<img src="http://cross-domain.com/image.jpg" crossorigin="anonymous">
// 读取图片数据
const img = new Image();
img.crossOrigin = "Anonymous";  // 需服务端支持CORS
img.onload = () => {
  canvas.getContext('2d').drawImage(img, 0, 0);
};

安全防护要点
1. CORS白名单：避免使用 Access-Control-Allow-Origin: * 
2. CSRF防护：
  ○ 敏感操作使用POST/PUT/DELETE
  ○ 添加CSRF Token验证
3. 代理服务器验证：避免开放型代理导致安全漏洞
4. JSONP过滤：验证回调函数名合法性
终极原则：
优先CORS → 开发用代理 → 特殊需求选WebSocket/postMessage
避免使用JSONP等安全性低的方案处理敏感数据