



Object 与 Map 核心区别解析
本质差异对比
特性	Object	Map
键类型	仅支持字符串/Symbol	支持任意类型（对象、函数等）
键顺序	ES6后保留插入顺序，但存在例外	严格保持插入顺序
默认属性	继承原型链属性（如toString）	纯净存储，无原型属性
大小获取	Object.keys().length	直接访问 size 属性
迭代能力	需手动转换（Object.entries）	原生可迭代（for...of）
性能敏感操作	删除/添加属性较慢	高频增删操作优化
序列化	原生支持 JSON 序列化	需手动转换

为什么需要设计 Map 类型
1. 解决键类型限制问题
// Object 键自动转字符串导致冲突
const obj = {};
obj[1] = '数字键';
obj['1'] = '字符串键';
console.log(obj); // { '1': '字符串键' } 值被覆盖

// Map 保留原始类型
const map = new Map();
map.set(1, '数字键');
map.set('1', '字符串键');
console.log(map.get(1));   // '数字键'
console.log(map.get('1')); // '字符串键'
2. 规避原型链污染风险
const obj = {};
console.log(obj.constructor); // 输出 Object 构造函数

const maliciousKey = '__proto__';
obj[maliciousKey] = { injected: true };
// 所有对象现在都有 injected 属性！

const map = new Map();
map.set('__proto__', 'safe');
console.log({}.injected); // undefined (无污染)
3. 高频操作性能优化
// 测试 10 万次删除操作 (Node.js v18)
const obj = {}, map = new Map();
for(let i=0; i<100000; i++) obj[i]=map.set(i,true);

console.time('Object删除');
Object.keys(obj).forEach(k => delete obj[k]); // ~120ms
console.timeEnd('Object删除');

console.time('Map删除');
map.clear(); // ~0.7ms (快170倍)
console.timeEnd('Map删除');
4. 内置迭代能力
const configMap = new Map([
  ['theme', 'dark'],
  ['locale', 'zh-CN'],
  ['apiVersion', 3]
]);

// 直接迭代
for(const [key, val] of configMap) {
  console.log(`${key}: ${val}`);
}

// 链式操作
const transformed = Array.from(configMap)
  .filter(([k]) => k !== 'apiVersion')
  .map(([k, v]) => [k, v.toUpperCase()]);
5. 避免意外覆盖默认方法
const obj = {
  get: '访问器属性', // 覆盖了 Object.prototype.get
  set: '设置器属性'  // 覆盖了 Object.prototype.set
};

const map = new Map();
map.set('get', '安全存储'); // 不会影响原型方法
map.set('set', '安全存储');

核心应用场景选择
场景	推荐类型	理由
简单键值存储	Object	语法简洁，JSON 友好
需要序列化	Object	原生支持 JSON.stringify
动态键值集合	Map	高频增删性能优势
非字符串键	Map	支持对象/函数等复杂键
需要顺序保证	Map	严格插入顺序
避免原型链干扰	Map	纯净数据容器
元编程/私有数据	Map	安全存储敏感信息
设计本质：
Map 是对 Object 的专业化补充，正如 Array 是对列表数据的专业化处理。
它解决了 Object 在复杂键支持、顺序保证、高频操作和安全隔离方面的固有缺陷，
为现代 JavaScript 提供了真正的键值对数据结构能力。