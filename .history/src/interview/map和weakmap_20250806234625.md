



1. 键类型要求
● Map  
  ○ 键可以是任意类型（对象、基本类型、函数等）  
  ○ 示例：map.set('name', 'John') 或 map.set(obj, 100)
● WeakMap  
  ○ 键必须是对象（非 null 的对象引用）  
  ○ 示例：weakmap.set(obj, metadata)（合法）  
  ○ 禁止：weakmap.set('key', value)（报错）
2. 内存管理机制
● Map  
let obj = { id: 1 };
const map = new Map();
map.set(obj, 'data');
obj = null; // 对象仍在 Map 中，无法被 GC 回收
  ○ 强引用键对象  
  ○ 即使键对象已无其他引用，仍不会被垃圾回收  
  ○ 导致内存泄漏风险：
● WeakMap  
let obj = { id: 1 };
const weakmap = new WeakMap();
weakmap.set(obj, 'data');
obj = null; // 下次 GC 时对象及关联数据被清除
  ○ 弱引用键对象  
  ○ 当键对象无其他引用时，自动被垃圾回收  
  ○ 关联值同时被释放：
3. 可迭代性与方法
能力	Map	WeakMap
遍历方法	keys()/values()	❌ 不可遍历
大小获取	size 属性	❌ 无 size 属性
批量操作	clear() 方法	❌ 无清除方法
序列化	支持 JSON 序列化	❌ 不可序列化
4. 性能表现
● 内存占用
WeakMap 内存增长更平缓（自动回收无引用键值对）  

● 查找速度
两者时间复杂度均为 O(1)，但 WeakMap 无遍历开销
5. 典型应用场景
● Map 适用  
  ○ 需遍历的键值集合（如缓存系统）  
  ○ 键为基本类型的场景（如字符串索引）  
  ○ 长期存在的全局存储
● WeakMap 适用  
const privateData = new WeakMap();

class User {
  constructor(name) {
    privateData.set(this, { name }); // 私有数据存储
  }
  getName() {
    return privateData.get(this).name;
  }
}
const domMetadata = new WeakMap();

document.querySelectorAll('.btn').forEach(btn => {
  domMetadata.set(btn, { clickCount: 0 });
  btn.addEventListener('click', () => {
    const data = domMetadata.get(btn);
    data.clickCount++;
  });
});

// 当DOM节点被移除时，关联数据自动GC
  ○ 对象关联元数据（不影响 GC 行为）
  ○ DOM 节点关联数据（节点移除自动清理）
  ○ 临时缓存系统（自动释放内存）
核心差异总结
维度	Map	WeakMap
键类型	任意类型	仅对象
引用强度	强引用（阻止GC）	弱引用（不阻止GC）
内存安全	需手动删除防泄漏	自动回收
功能完备性	完整API（遍历/清空等）	仅基础操作（set/get/has）
设计目的	通用键值存储	对象关联的临时元数据存储
使用铁律：
当需要存储对象关联数据且希望自动内存管理时，必选 WeakMap；
其他所有键值存储需求均使用 Map。