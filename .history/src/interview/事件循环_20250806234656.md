


事件循环（Event Loop）核心概念
本质：JavaScript 单线程运行时处理异步任务的调度机制，通过循环监控任务队列实现非阻塞执行。

任务队列（Task Queue）分层模型
1. 宏任务队列（Macrotask Queue）
  ○ 来源：宿主环境触发的任务
  ○ 包含：
    ■ setTimeout / setInterval
    ■ I/O 操作（文件/网络）
    ■ DOM 事件回调（点击/滚动）
    ■ requestAnimationFrame（浏览器）
    ■ setImmediate（Node.js）
  ○ 执行规则：每轮事件循环只取一个宏任务执行
2. 微任务队列（Microtask Queue）
  ○ 来源：JavaScript 引擎生成的任务
  ○ 包含：
    ■ Promise.then/catch/finally
    ■ MutationObserver（DOM 变更监听）
    ■ queueMicrotask API
    ■ process.nextTick（Node.js，优先级最高）
  ○ 执行规则：每轮事件循环清空整个微任务队列

执行流程（浏览器环境）

关键步骤解析：
1. 同步代码执行：主线程执行完所有同步任务
2. 微任务清算阶段：
  ○ 执行所有微任务队列中的任务
  ○ 微任务执行中产生的新微任务立即加入当前队列
  ○ 直到微任务队列完全清空
3. UI渲染（非必须）：浏览器决定是否进行 DOM 渲染
4. 宏任务提取：从宏任务队列中取出最早的一个任务执行
5. 循环重启：回到步骤1开始新的事件循环

经典执行顺序案例
console.log('同步1');

setTimeout(() => console.log('宏任务1'));

Promise.resolve()
  .then(() => console.log('微任务1'))
  .then(() => console.log('微任务2'));

queueMicrotask(() => console.log('微任务3'));

console.log('同步2');

/* 输出顺序：
   同步1
   同步2
   微任务1
   微任务3
   微任务2
   宏任务1
*/
执行过程拆解：
1. 执行同步代码：打印 同步1 → 同步2
2. 清空微任务队列：
  ○ 执行 Promise.then：打印 微任务1
  ○ 执行 queueMicrotask：打印 微任务3
  ○ 执行 Promise 链式 then：打印 微任务2
3. 执行下一个宏任务：打印 宏任务1

特殊场景规则
1. 微任务优先级：
  ○ process.nextTick > Promise.then（Node.js）
  ○ 同类型微任务按入队顺序执行
2. 渲染时机：
  ○ 在微任务执行后，宏任务执行前
  ○ requestAnimationFrame 属于渲染前执行的宏任务
3. 阻塞警告：
// 错误示例：微任务死循环将阻塞主线程
function blockLoop() {
  Promise.resolve().then(blockLoop);
}

设计意义与最佳实践
1. 用户响应优先：微任务机制确保高优先级操作（如 Promise）先于 UI 渲染和宏任务执行
2. 性能优化原则：
  ○ 耗时操作拆解为多个宏任务（避免阻塞渲染）
  ○ 状态更新等高频操作使用微任务（避免布局抖动）
3. 框架应用：
  ○ Vue 的 nextTick 优先使用微任务实现异步更新
  ○ React 调度器基于宏任务分片执行机制
核心要诀：
同步代码 → 清空微任务 → 渲染 → 取宏任务 → 循环
微任务在同轮循环清算，宏任务在下轮循环执行