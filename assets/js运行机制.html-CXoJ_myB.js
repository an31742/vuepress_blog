import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,o as e,a as i}from"./app-Co5ZRGLE.js";const a={},l=i(`<h1 id="js-运行机制" tabindex="-1"><a class="header-anchor" href="#js-运行机制"><span>JS 运行机制</span></a></h1><ul><li>浏览器和node.js支持js启动进程 webworker</li><li>js和dom渲染共用一个线程，因为js可以修改Dom结构</li><li>js异步要基于回调来实现</li></ul><p><strong>异步任务（setTimeout ajax）使用回调函数  基于event loop</strong><strong>dom事件(dom事件不是异步)使用回调函数 基于event loop</strong></p><h3 id="js如何执行的" tabindex="-1"><a class="header-anchor" href="#js如何执行的"><span>js如何执行的</span></a></h3><ul><li>从前到后一行一行的执行</li><li>如果某一行执行报错，则停止下面的代码执行</li><li>先把同步代码执行完，再执行异步的代码</li></ul><h3 id="如何理解单线程" tabindex="-1"><a class="header-anchor" href="#如何理解单线程"><span>如何理解单线程</span></a></h3><ul><li>JS是单线程，同一时间只能做一件事</li><li>异步。node叫非阻塞IO。</li></ul><h3 id="什么是任务队列" tabindex="-1"><a class="header-anchor" href="#什么是任务队列"><span>什么是任务队列</span></a></h3><ul><li>事件队列：任务队列。分为同步任务、异步任务。加载完JS，整个线程优先处理同步任务，再处理异步任务。无论你的同步有多少，异步多及时。都是这样。也有同步队列，和异步队列。</li><li>node叫事件环机制，就是我理解的事件调度中心，优先处理先来用户的请求。</li><li>同步任务，或者异步返回一个无限循环，后面的任务都会被阻塞。</li><li>JS有个timer模块，遇到time函数，会记住函数的执行时机开始倒计时，到了该执行的时间后，才把函数插入异步队列。</li></ul><h3 id="什么是event-loop-事件循环-事件轮询" tabindex="-1"><a class="header-anchor" href="#什么是event-loop-事件循环-事件轮询"><span>什么是Event loop 事件循环 事件轮询</span></a></h3><p>原理：eventloop 是异步回调机制的实现原理</p><p>【实现机制】：</p><ul><li>遇到同步代码一行一行放到callStack里面执行</li><li>遇到异步会先记录下，等待时机执行异步事件的时间结束 会将异步事件放到callback queue</li><li>callstack为空的时候，(同步代码全部执行完) eventloop机制开始工作</li><li>事件轮询查找callback queue，是否有可执行事件移动到call Stack里面执行</li><li>如果没有继续查找</li><li>【同步队列】，执行完成时，i=4,然后异步队列没有函数，timer等待时间到达，就是把函数推入异步队列，再等待一个【事件循环】的东西，再开始执行异步队列，所有是4个4.</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>for (var i = 0; i &lt; 4; i++) {</span></span>
<span class="line"><span>  setTimeout(function () {</span></span>
<span class="line"><span>    console.log(i);  // 4*4</span></span>
<span class="line"><span>  },0);</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>【事件循环】：先把【同步队列】的函数放【运行栈】上执行，执行完成，有个【东西】就去看【异步队列】上有没有函数，timer模块把到时间的函数，放入【异步队列】，这个【东西】就会把【异步队列】的函数拿到运行栈上执行，执行完成后，再次重复前面的过程。这个【东西】和返回查看同步队列和异步的过程，叫事件循环。</li></ul><h3 id="异步任务" tabindex="-1"><a class="header-anchor" href="#异步任务"><span>异步任务</span></a></h3><ul><li>SetTimeout/setinterval</li><li>DOM的事件：浏览器有单独模块去接受这个函数，GUI监听用户点击某个按钮触发函数的时候，这个模块就会把这个函数推到【异步队列】中，【事件循环】会监测、拿走、执行这个函数。</li><li>ES6中的promise。</li></ul><hr><h1 id="宏任务、微任务" tabindex="-1"><a class="header-anchor" href="#宏任务、微任务"><span>宏任务、微任务</span></a></h1><p>微任务要优先红任务执行</p><ul><li>先看代码</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>console.log(&#39;script start&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>setTimeout(function() {</span></span>
<span class="line"><span>  console.log(&#39;setTimeout&#39;);</span></span>
<span class="line"><span>}, 0);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Promise.resolve().then(function() {</span></span>
<span class="line"><span>  console.log(&#39;promise1&#39;);</span></span>
<span class="line"><span>}).then(function() {</span></span>
<span class="line"><span>  console.log(&#39;promise2&#39;);</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>console.log(&#39;script end&#39;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>正确答案是：script start, script end, promise1, promise2, setTimeout</li><li>每个线程都会有它自己的event loop(事件循环)，所以都能独立运行。然而所有同源窗口会共享一个event loop以同步通信。event loop会一直运行，来执行进入队列的宏任务。一个event loop有多种的宏任务源（译者注：event等等），这些宏任务源保证了在本任务源内的顺序。但是浏览器每次都会选择一个源中的一个宏任务去执行。这保证了浏览器给与一些宏任务（如用户输入）以更高的优先级。</li></ul><h3 id="宏任务-task" tabindex="-1"><a class="header-anchor" href="#宏任务-task"><span>宏任务（task）</span></a></h3><ul><li>浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染</li><li>task-&gt;渲染-&gt;task-&gt;...</li><li>鼠标点击会触发一个事件回调，需要执行一个宏任务，然后解析HTMl。</li><li>setTimeout的作用是等待给定的时间后为它的回调产生一个新的宏任务。这就是为什么打印‘setTimeout’在‘script end’之后。</li><li>因为打印script end是第一个宏任务里面的事情，而‘setTimeout’是另一个独立的任务里面打印的。</li><li>setTimeout setInterval ajax Dom事件</li></ul><h3 id="微任务-microtasks" tabindex="-1"><a class="header-anchor" href="#微任务-microtasks"><span>微任务（Microtasks ）</span></a></h3><ul><li>promise async和await</li><li>微任务通常来说就是需要在当前 task 执行结束后立即执行的任务，比如对一系列动作做出反馈，或者是需要异步的执行任务而又不需要分配一个新的 task，这样便可以减小一点性能的开销。</li><li>只要执行栈中没有其他的js代码正在执行且每个宏任务执行完，微任务队列会立即执行。</li><li>如果在微任务执行期间微任务队列加入了新的微任务，会将新的微任务加入队列尾部，之后也会被执行。</li><li>微任务包括了mutation observe的回调还有接下来的例子promise的回调。</li><li>一旦一个pormise有了结果，或者早已有了结果（有了结果是指这个promise到了fulfilled或rejected状态），他就会为它的回调产生一个微任务，这就保证了回调异步的执行即使这个promise早已有了结果。</li><li>所以对一个已经有了结果的promise调用.then(yey, nay)会立即产生一个微任务。这就是为什么‘promise1’,&#39;promise2&#39;会打印在‘script end’之后，</li><li>因为所有微任务执行的时候，当前执行栈的代码必须已经执行完毕。‘promise1’,&#39;promise2&#39;会打印在‘setTimeout’之前是因为所有微任务总会在下一个宏任务之前全部执行完毕。</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// Let&#39;s get hold of those elements</span></span>
<span class="line"><span>var outer = document.querySelector(&#39;.outer&#39;);</span></span>
<span class="line"><span>var inner = document.querySelector(&#39;.inner&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Let&#39;s listen for attribute changes on the</span></span>
<span class="line"><span>// outer element</span></span>
<span class="line"><span>//监听element属性变化</span></span>
<span class="line"><span>new MutationObserver(function() {</span></span>
<span class="line"><span>  console.log(&#39;mutate&#39;);</span></span>
<span class="line"><span>}).observe(outer, {</span></span>
<span class="line"><span>  attributes: true</span></span>
<span class="line"><span>});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Here&#39;s a click listener…</span></span>
<span class="line"><span>function onClick() {</span></span>
<span class="line"><span>  console.log(&#39;click&#39;);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  setTimeout(function() {</span></span>
<span class="line"><span>    console.log(&#39;timeout&#39;);</span></span>
<span class="line"><span>  }, 0);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  Promise.resolve().then(function() {</span></span>
<span class="line"><span>    console.log(&#39;promise&#39;);</span></span>
<span class="line"><span>  });</span></span>
<span class="line"><span></span></span>
<span class="line"><span>  outer.setAttribute(&#39;data-random&#39;, Math.random());</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// …which we&#39;ll attach to both elements</span></span>
<span class="line"><span>inner.addEventListener(&#39;click&#39;, onClick);</span></span>
<span class="line"><span>outer.addEventListener(&#39;click&#39;, onClick);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>谷歌</li></ul><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>click</span></span>
<span class="line"><span>promise</span></span>
<span class="line"><span>mutate</span></span>
<span class="line"><span>click</span></span>
<span class="line"><span>promise</span></span>
<span class="line"><span>mutate</span></span>
<span class="line"><span>timeout</span></span>
<span class="line"><span>timeout</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,30),t=[l];function p(r,c){return e(),n("div",null,t)}const m=s(a,[["render",p],["__file","js运行机制.html.vue"]]),v=JSON.parse('{"path":"/frontEndInterview/JavaScript/js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.html","title":"JS 运行机制","lang":"zh-CN","frontmatter":{"title":"JS 运行机制","icon":"circle-info","description":"JS 运行机制 浏览器和node.js支持js启动进程 webworker js和dom渲染共用一个线程，因为js可以修改Dom结构 js异步要基于回调来实现 异步任务（setTimeout ajax）使用回调函数 基于event loop dom事件(dom事件不是异步)使用回调函数 基于event loop js如何执行的 从前到后一行一行的执行 ...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/frontEndInterview/JavaScript/js%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6.html"}],["meta",{"property":"og:site_name","content":"前端知识随笔"}],["meta",{"property":"og:title","content":"JS 运行机制"}],["meta",{"property":"og:description","content":"JS 运行机制 浏览器和node.js支持js启动进程 webworker js和dom渲染共用一个线程，因为js可以修改Dom结构 js异步要基于回调来实现 异步任务（setTimeout ajax）使用回调函数 基于event loop dom事件(dom事件不是异步)使用回调函数 基于event loop js如何执行的 从前到后一行一行的执行 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-23T10:03:41.000Z"}],["meta",{"property":"article:author","content":"小安"}],["meta",{"property":"article:modified_time","content":"2024-06-23T10:03:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"JS 运行机制\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-06-23T10:03:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小安\\",\\"url\\":\\"https://github.com/an31742\\"}]}"]]},"headers":[{"level":3,"title":"js如何执行的","slug":"js如何执行的","link":"#js如何执行的","children":[]},{"level":3,"title":"如何理解单线程","slug":"如何理解单线程","link":"#如何理解单线程","children":[]},{"level":3,"title":"什么是任务队列","slug":"什么是任务队列","link":"#什么是任务队列","children":[]},{"level":3,"title":"什么是Event loop 事件循环 事件轮询","slug":"什么是event-loop-事件循环-事件轮询","link":"#什么是event-loop-事件循环-事件轮询","children":[]},{"level":3,"title":"异步任务","slug":"异步任务","link":"#异步任务","children":[]},{"level":3,"title":"宏任务（task）","slug":"宏任务-task","link":"#宏任务-task","children":[]},{"level":3,"title":"微任务（Microtasks ）","slug":"微任务-microtasks","link":"#微任务-microtasks","children":[]}],"git":{"createdTime":1719137021000,"updatedTime":1719137021000,"contributors":[{"name":"an31742","email":"2234170284@qq.com","commits":1}]},"readingTime":{"minutes":5.34,"words":1601},"filePathRelative":"frontEndInterview/JavaScript/js运行机制.md","localizedDate":"2024年6月23日","autoDesc":true}');export{m as comp,v as data};
