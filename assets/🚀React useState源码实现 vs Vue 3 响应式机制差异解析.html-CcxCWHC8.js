import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as a,c as n,d as t,w as i,a as l,o as r,f as d}from"./app-CUO35lTv.js";const p={},c=l(`<hr><h2 id="_1️⃣-本质透视镜-usestate-与-vue3-响应式的核心区别" tabindex="-1"><a class="header-anchor" href="#_1️⃣-本质透视镜-usestate-与-vue3-响应式的核心区别"><span><strong>1️⃣</strong>** 本质透视镜：useState 与 Vue3 响应式的核心区别**</span></a></h2><p><strong>本质是：调度模型差异 + 数据依赖追踪方式不同</strong></p><ul><li>useState 本质：<strong>基于 Fiber 的更新调度系统 + 队列式状态存储</strong></li><li>Vue3 响应式本质：<strong>基于 Proxy 的依赖收集 + 精细粒度的响应式追踪</strong></li></ul><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>- React（useState） = 队列状态更新 + 调度触发渲染</span></span>
<span class="line"><span>- Vue3（ref/reactive）= 自动依赖收集 + 变更追踪更新</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_2️⃣-关系拓扑图-从调度链到响应更新的核心差异" tabindex="-1"><a class="header-anchor" href="#_2️⃣-关系拓扑图-从调度链到响应更新的核心差异"><span><strong>2️⃣</strong>** 关系拓扑图：从调度链到响应更新的核心差异**</span></a></h2><h3 id="👁️-当-setstate-时-会触发" tabindex="-1"><a class="header-anchor" href="#👁️-当-setstate-时-会触发"><span><strong>👁️</strong>** 当 setState 时，会触发…**</span></a></h3><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>用户调用 setState(x)</span></span>
<span class="line"><span>      ↓</span></span>
<span class="line"><span>状态值压入 updateQueue（Update 对象）</span></span>
<span class="line"><span>      ↓</span></span>
<span class="line"><span>调度 scheduler（requestUpdateLane）标记本次更新优先级</span></span>
<span class="line"><span>      ↓</span></span>
<span class="line"><span>React Fiber 重建工作单元树（workInProgress tree）</span></span>
<span class="line"><span>      ↓</span></span>
<span class="line"><span>触发 render → commit → DOM 更新</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="🔁-vue3-的响应式依赖链" tabindex="-1"><a class="header-anchor" href="#🔁-vue3-的响应式依赖链"><span><strong>🔁</strong>** Vue3 的响应式依赖链：**</span></a></h3><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>ref.value = x</span></span>
<span class="line"><span>      ↓</span></span>
<span class="line"><span>触发 Proxy.set handler</span></span>
<span class="line"><span>      ↓</span></span>
<span class="line"><span>通过 ReactiveEffect 重新收集依赖</span></span>
<span class="line"><span>      ↓</span></span>
<span class="line"><span>Scheduler 调度 effect → 只执行依赖这个值的副作用函数</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><h2 id="_3️⃣-行动意义锚点-为什么深入理解这两者有价值" tabindex="-1"><a class="header-anchor" href="#_3️⃣-行动意义锚点-为什么深入理解这两者有价值"><span><strong>3️⃣</strong>** 行动意义锚点：为什么深入理解这两者有价值？**</span></a></h2><p><strong>核心价值是：明确响应式系统的“性能瓶颈”与“设计哲学”</strong></p><p>如果你不深入理解这两种机制：</p><ul><li>❌ 可能误用 React 的 setState，导致多次渲染</li><li>❌ 忽视 Vue3 响应式副作用清理，出现内存泄漏</li><li>❌ 在组件性能优化上无从下手</li></ul><p>反之，掌握两者底层原理可以：</p><p>✅ <strong>优化组件结构</strong>：合并不必要的 setState、合理拆 effect</p><p>✅ <strong>提升调试效率</strong>：快速定位为何某个响应式值未更新</p><p>✅ <strong>撰写更强健的组件</strong>：更贴近底层的写法避免踩坑</p><hr><h2 id="_4️⃣-步骤拆解器-react" tabindex="-1"><a class="header-anchor" href="#_4️⃣-步骤拆解器-react"><span><strong>4️⃣</strong>** 步骤拆解器：React**** **</span></a></h2><h2 id="usestate" tabindex="-1"><a class="header-anchor" href="#usestate"><span><strong>useState</strong></span></a></h2><h2 id="源码实现逻辑" tabindex="-1"><a class="header-anchor" href="#源码实现逻辑"><span>****<strong>源码实现逻辑</strong></span></a></h2><h3 id="📌" tabindex="-1"><a class="header-anchor" href="#📌"><span><strong>📌</strong>** **</span></a></h3><h3 id="usestate-1" tabindex="-1"><a class="header-anchor" href="#usestate-1"><span><strong>useState</strong></span></a></h3><h3 id="实现路径-react-v18" tabindex="-1"><a class="header-anchor" href="#实现路径-react-v18"><span>****<strong>实现路径（React v18）：</strong></span></a></h3><h4 id="_1-创建-hook-数据结构" tabindex="-1"><a class="header-anchor" href="#_1-创建-hook-数据结构"><span><strong>① 创建 Hook 数据结构</strong></span></a></h4><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 以链表形式挂载在 fiber.memoizedState 上</span></span>
<span class="line"><span>const hook = {</span></span>
<span class="line"><span>  memoizedState: initialState,</span></span>
<span class="line"><span>  baseState: initialState,</span></span>
<span class="line"><span>  queue: {</span></span>
<span class="line"><span>    pending: null</span></span>
<span class="line"><span>  },</span></span>
<span class="line"><span>  next: null</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_2-更新时将新状态压入-updatequeue" tabindex="-1"><a class="header-anchor" href="#_2-更新时将新状态压入-updatequeue"><span><strong>② 更新时将新状态压入 updateQueue</strong></span></a></h4><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// 形成链表队列（Lanes 优先级控制调度）</span></span>
<span class="line"><span>const update = {</span></span>
<span class="line"><span>  lane,</span></span>
<span class="line"><span>  action,</span></span>
<span class="line"><span>  next</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3-render-阶段处理-update-queue-reducer-模式" tabindex="-1"><a class="header-anchor" href="#_3-render-阶段处理-update-queue-reducer-模式"><span><strong>③ render 阶段处理 update queue（reducer 模式）</strong></span></a></h4><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>newState = processQueue(hook.queue, prevState);</span></span>
<span class="line"><span>hook.memoizedState = newState;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4-触发调度更新-scheduleupdateonfiber" tabindex="-1"><a class="header-anchor" href="#_4-触发调度更新-scheduleupdateonfiber"><span><strong>④ 触发调度更新（scheduleUpdateOnFiber）</strong></span></a></h4><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>scheduleUpdateOnFiber(fiber, lane);</span></span>
<span class="line"><span>// 最终触发 render → commit 阶段</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>❗ <strong>注意：React 中一次 render 不会立即更新 DOM，而是等待 commit 阶段统一处理。</strong></p><hr><h2 id="🎯-vue3-响应式系统核心实现流程-简化版" tabindex="-1"><a class="header-anchor" href="#🎯-vue3-响应式系统核心实现流程-简化版"><span><strong>🎯</strong>** Vue3 响应式系统核心实现流程（简化版）**</span></a></h2><h3 id="📍" tabindex="-1"><a class="header-anchor" href="#📍"><span><strong>📍</strong>** **</span></a></h3><h3 id="ref" tabindex="-1"><a class="header-anchor" href="#ref"><span><strong>ref</strong></span></a></h3><h3 id="的本质是" tabindex="-1"><a class="header-anchor" href="#的本质是"><span>****<strong>的本质是：</strong></span></a></h3><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>function ref(value) {</span></span>
<span class="line"><span>  return {</span></span>
<span class="line"><span>    get value() {</span></span>
<span class="line"><span>      track(effect);</span></span>
<span class="line"><span>      return rawValue;</span></span>
<span class="line"><span>    },</span></span>
<span class="line"><span>    set value(newVal) {</span></span>
<span class="line"><span>      rawValue = newVal;</span></span>
<span class="line"><span>      trigger(effect);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="📌-与-react-最大不同" tabindex="-1"><a class="header-anchor" href="#📌-与-react-最大不同"><span><strong>📌</strong>** 与 React 最大不同：**</span></a></h3><table><thead><tr><th><strong>维度</strong></th><th>**React **useState</th><th>**Vue 3 **ref/reactive</th></tr></thead><tbody><tr><td>状态存储</td><td>每个 hook 单独存储</td><td>Proxy 拦截原始对象</td></tr><tr><td>更新调度</td><td>调度全组件更新</td><td>精细调度响应依赖</td></tr><tr><td>响应追踪</td><td>无依赖追踪（需显式 set）</td><td>自动追踪依赖（track/trigger）</td></tr><tr><td>更新机制</td><td>队列 + Fiber 重建</td><td>effect 函数重执行</td></tr><tr><td>异步合并</td><td>批量更新（batched）</td><td>异步更新（nextTick）</td></tr></tbody></table><hr><h2 id="🧠-总结-设计哲学差异" tabindex="-1"><a class="header-anchor" href="#🧠-总结-设计哲学差异"><span><strong>🧠</strong>** 总结：设计哲学差异**</span></a></h2><table><thead><tr><th><strong>对比点</strong></th><th><strong>React</strong></th><th><strong>Vue3</strong></th></tr></thead><tbody><tr><td>哲学</td><td>UI = f(state)，每次重算组件树</td><td>响应式系统自动追踪依赖</td></tr><tr><td>数据驱动方式</td><td>调度优先，避免不必要更新</td><td>精细依赖更新，粒度细</td></tr><tr><td>易用性</td><td>状态显式管理清晰</td><td>依赖隐式收集强大</td></tr><tr><td>性能调优</td><td>Fiber 优先级调度为主</td><td>Proxy + Effect 精细更新为主</td></tr></tbody></table><hr><h2 id="🔚-最后的建议" tabindex="-1"><a class="header-anchor" href="#🔚-最后的建议"><span><strong>🔚</strong>** 最后的建议**</span></a></h2><ul><li>如果你来自 Vue 背景学习 React：<strong>注意 setState 的“惰性”与批处理行为</strong></li><li>如果你来自 React 背景学习 Vue：<strong>理解副作用系统中的自动依赖追踪与 effect 的作用</strong></li></ul><hr><h2 id="📎-附加资源推荐" tabindex="-1"><a class="header-anchor" href="#📎-附加资源推荐"><span><strong>📎</strong>** 附加资源推荐**</span></a></h2><ul><li><a href="https://reactjs.org/docs/faq-internals.html" target="_blank" rel="noopener noreferrer">React 官方架构解析：Fiber</a></li><li><a href="https://vuejs.org/guide/extras/reactivity-in-depth.html" target="_blank" rel="noopener noreferrer">Vue3 响应式系统设计文档（英文原版）</a></li><li>深入阅读源码建议： <ul><li>React：packages/react-reconciler/src/ReactFiberHooks.js</li><li>Vue3：packages/reactivity/src/reactive.ts</li></ul></li></ul><hr><p>如果你希望我把这篇博客导出成 Markdown 文件、Notion 风格或 PDF，请告诉我格式即可 ✅</p><p>也可以为你生成<strong>对比图谱、状态流图、源码注释对照图</strong>等可视化内容。是否需要？</p>`,56);function h(o,u){const e=a("font");return r(),n("div",null,[t(e,{style:{color:"#0e0e0e"}},{default:i(()=>[d("本文通过源码视角，深入剖析 React useState 实现原理，并对比 Vue 3 的响应式系统，帮助你理解背后的设计哲学与性能策略差异。")]),_:1}),c])}const b=s(p,[["render",h],["__file","🚀React useState源码实现 vs Vue 3 响应式机制差异解析.html.vue"]]),m=JSON.parse('{"path":"/businessProblem/%E8%BF%9B%E9%98%B6/%F0%9F%9A%80React%20useState%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%20vs%20Vue%203%20%E5%93%8D%E5%BA%94%E5%BC%8F%E6%9C%BA%E5%88%B6%E5%B7%AE%E5%BC%82%E8%A7%A3%E6%9E%90.html","title":"React useState 源码实现 vs Vue 3 响应式机制差异解析","lang":"zh-CN","frontmatter":{"title":"React useState 源码实现 vs Vue 3 响应式机制差异解析","icon":"circle-info","description":"1️⃣** 本质透视镜：useState 与 Vue3 响应式的核心区别** 本质是：调度模型差异 + 数据依赖追踪方式不同 useState 本质：基于 Fiber 的更新调度系统 + 队列式状态存储 Vue3 响应式本质：基于 Proxy 的依赖收集 + 精细粒度的响应式追踪 2️⃣** 关系拓扑图：从调度链到响应更新的核心差异** 👁️** 当...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/businessProblem/%E8%BF%9B%E9%98%B6/%F0%9F%9A%80React%20useState%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%20vs%20Vue%203%20%E5%93%8D%E5%BA%94%E5%BC%8F%E6%9C%BA%E5%88%B6%E5%B7%AE%E5%BC%82%E8%A7%A3%E6%9E%90.html"}],["meta",{"property":"og:site_name","content":"前端知识随笔"}],["meta",{"property":"og:title","content":"React useState 源码实现 vs Vue 3 响应式机制差异解析"}],["meta",{"property":"og:description","content":"1️⃣** 本质透视镜：useState 与 Vue3 响应式的核心区别** 本质是：调度模型差异 + 数据依赖追踪方式不同 useState 本质：基于 Fiber 的更新调度系统 + 队列式状态存储 Vue3 响应式本质：基于 Proxy 的依赖收集 + 精细粒度的响应式追踪 2️⃣** 关系拓扑图：从调度链到响应更新的核心差异** 👁️** 当..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-28T13:02:59.000Z"}],["meta",{"property":"article:author","content":"小安"}],["meta",{"property":"article:modified_time","content":"2025-07-28T13:02:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"React useState 源码实现 vs Vue 3 响应式机制差异解析\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-28T13:02:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小安\\",\\"url\\":\\"https://github.com/an31742\\"}]}"]]},"headers":[{"level":2,"title":"1️⃣** 本质透视镜：useState 与 Vue3 响应式的核心区别**","slug":"_1️⃣-本质透视镜-usestate-与-vue3-响应式的核心区别","link":"#_1️⃣-本质透视镜-usestate-与-vue3-响应式的核心区别","children":[]},{"level":2,"title":"2️⃣** 关系拓扑图：从调度链到响应更新的核心差异**","slug":"_2️⃣-关系拓扑图-从调度链到响应更新的核心差异","link":"#_2️⃣-关系拓扑图-从调度链到响应更新的核心差异","children":[{"level":3,"title":"👁️** 当 setState 时，会触发…**","slug":"👁️-当-setstate-时-会触发","link":"#👁️-当-setstate-时-会触发","children":[]},{"level":3,"title":"🔁** Vue3 的响应式依赖链：**","slug":"🔁-vue3-的响应式依赖链","link":"#🔁-vue3-的响应式依赖链","children":[]}]},{"level":2,"title":"3️⃣** 行动意义锚点：为什么深入理解这两者有价值？**","slug":"_3️⃣-行动意义锚点-为什么深入理解这两者有价值","link":"#_3️⃣-行动意义锚点-为什么深入理解这两者有价值","children":[]},{"level":2,"title":"4️⃣** 步骤拆解器：React**** **","slug":"_4️⃣-步骤拆解器-react","link":"#_4️⃣-步骤拆解器-react","children":[]},{"level":2,"title":"useState","slug":"usestate","link":"#usestate","children":[]},{"level":2,"title":"****源码实现逻辑","slug":"源码实现逻辑","link":"#源码实现逻辑","children":[{"level":3,"title":"📌** **","slug":"📌","link":"#📌","children":[]},{"level":3,"title":"useState","slug":"usestate-1","link":"#usestate-1","children":[]},{"level":3,"title":"****实现路径（React v18）：","slug":"实现路径-react-v18","link":"#实现路径-react-v18","children":[]}]},{"level":2,"title":"🎯** Vue3 响应式系统核心实现流程（简化版）**","slug":"🎯-vue3-响应式系统核心实现流程-简化版","link":"#🎯-vue3-响应式系统核心实现流程-简化版","children":[{"level":3,"title":"📍** **","slug":"📍","link":"#📍","children":[]},{"level":3,"title":"ref","slug":"ref","link":"#ref","children":[]},{"level":3,"title":"****的本质是：","slug":"的本质是","link":"#的本质是","children":[]},{"level":3,"title":"📌** 与 React 最大不同：**","slug":"📌-与-react-最大不同","link":"#📌-与-react-最大不同","children":[]}]},{"level":2,"title":"🧠** 总结：设计哲学差异**","slug":"🧠-总结-设计哲学差异","link":"#🧠-总结-设计哲学差异","children":[]},{"level":2,"title":"🔚** 最后的建议**","slug":"🔚-最后的建议","link":"#🔚-最后的建议","children":[]},{"level":2,"title":"📎** 附加资源推荐**","slug":"📎-附加资源推荐","link":"#📎-附加资源推荐","children":[]}],"git":{"createdTime":1753707779000,"updatedTime":1753707779000,"contributors":[{"name":"an31742","email":"2234170284@qq.com","commits":1}]},"readingTime":{"minutes":3.39,"words":1017},"filePathRelative":"businessProblem/进阶/🚀React useState源码实现 vs Vue 3 响应式机制差异解析.md","localizedDate":"2025年7月28日","autoDesc":true}');export{b as comp,m as data};
