import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as l,c as r,d as s,w as t,f as e,a as n,o as d}from"./app-CUO35lTv.js";const c={},p=n(`<h2 id="_1️⃣-本质透视镜-是什么" tabindex="-1"><a class="header-anchor" href="#_1️⃣-本质透视镜-是什么"><span><strong>1️⃣</strong>** 本质透视镜：是什么？**</span></a></h2><p><strong>本质是</strong>：Next.js 中两种不同层级的缓存控制机制，分别用于</p><p>→ unstable_cache: <strong>函数级缓存</strong></p><p>→ revalidate: <strong>路由级 ISR 缓存控制</strong></p><p>这其实就是：<strong>执行层 vs 构建层的缓存粒度控制工具</strong>。</p><hr><h2 id="_2️⃣-关系拓扑图-为什么存在" tabindex="-1"><a class="header-anchor" href="#_2️⃣-关系拓扑图-为什么存在"><span><strong>2️⃣</strong>** 关系拓扑图：为什么存在？**</span></a></h2><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>getStaticProps → HTML + JSON 生成 → 缓存（基于 revalidate）  </span></span>
<span class="line"><span>                               ↑  </span></span>
<span class="line"><span>                      请求触发 ISR 判断</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fetch/DB 调用 → 使用 unstable_cache → 结果缓存 → 减少 I/O 开销</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li>revalidate: 控制 <strong>页面级生成的 HTML/JSON 缓存刷新时间</strong></li><li>unstable_cache: 控制 <strong>某个函数（如 API/fetch）在构建/请求时缓存调用结果</strong></li></ul><h3 id="⚠️-关键区别" tabindex="-1"><a class="header-anchor" href="#⚠️-关键区别"><span><strong>⚠️</strong>** 关键区别：**</span></a></h3><table><thead><tr><th><strong>特性</strong></th><th>revalidate</th><th>unstable_cache</th></tr></thead><tbody><tr><td>缓存粒度</td><td>页面（route）</td><td>函数（业务逻辑）</td></tr><tr><td>触发时机</td><td>请求到达时</td><td>函数执行时</td></tr><tr><td>配置位置</td><td>页面文件（generateStaticParams、revalidate）</td><td>函数包装器</td></tr><tr><td>数据类型</td><td>静态内容（HTML/JSON）</td><td>任意数据（fetch, db, etc）</td></tr><tr><td>缓存位置</td><td>Edge / CDN 层</td><td>Edge + Memory 层</td></tr></tbody></table><hr><h2 id="_3️⃣-行动意义锚点-为什么要用" tabindex="-1"><a class="header-anchor" href="#_3️⃣-行动意义锚点-为什么要用"><span><strong>3️⃣</strong>** 行动意义锚点：为什么要用？**</span></a></h2><p><strong>核心价值是：</strong></p><p>精准缓存控制，<strong>提升性能 &amp; 减少冷启动开销</strong></p><table><thead><tr><th><strong>如果不做缓存</strong></th><th><strong>如果正确使用缓存</strong></th></tr></thead><tbody><tr><td>SSR/动态请求压力大</td><td>减少重复数据库调用</td></tr><tr><td>用户每次访问都触发 API 调用</td><td>重用缓存内容，TTFB 降低</td></tr><tr><td>无法预估缓存时效性</td><td>精准控制某段逻辑缓存时间</td></tr></tbody></table><p>✅ <strong>业务绑定示例：</strong></p>`,17),o=n(`<hr><h2 id="_4️⃣-步骤拆解器-怎么做" tabindex="-1"><a class="header-anchor" href="#_4️⃣-步骤拆解器-怎么做"><span><strong>4️⃣</strong>** 步骤拆解器：怎么做？**</span></a></h2><h3 id="✅-revalidate实战-路由级缓存" tabindex="-1"><a class="header-anchor" href="#✅-revalidate实战-路由级缓存"><span><strong>✅</strong>** revalidate实战（路由级缓存）**</span></a></h3><p>操作路径：</p><p>① 在页面中添加 export const revalidate = 60</p><p>→ 页面静态构建后，每 60s 触发一次再生成</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>// app/products/page.tsx</span></span>
<span class="line"><span>export const revalidate = 60;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>export default async function ProductsPage() {</span></span>
<span class="line"><span>  const res = await fetch(&#39;https://api.example.com/products&#39;);</span></span>
<span class="line"><span>  const data = await res.json();</span></span>
<span class="line"><span>  return &lt;ProductList data={data} /&gt;;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>❗注意：</p><ul><li>页面将生成静态 HTML 和 JSON，60 秒之后重新构建</li><li>浏览器和 CDN 层依旧命中缓存</li></ul><hr><h3 id="✅-unstable-cache-实战-函数级缓存" tabindex="-1"><a class="header-anchor" href="#✅-unstable-cache-实战-函数级缓存"><span><strong>✅</strong>** unstable_cache 实战（函数级缓存）**</span></a></h3><p>操作路径：</p><p>① 将目标函数（如 fetch、DB 查询）用 unstable_cache 包裹</p><p>② 设置自定义缓存 key 和失效时间</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>import { unstable_cache } from &#39;next/cache&#39;;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const getProducts = unstable_cache(</span></span>
<span class="line"><span>  async () =&gt; {</span></span>
<span class="line"><span>    const res = await fetch(&#39;https://api.example.com/products&#39;);</span></span>
<span class="line"><span>    return res.json();</span></span>
<span class="line"><span>  },</span></span>
<span class="line"><span>  [&#39;products&#39;], // 缓存 key</span></span>
<span class="line"><span>  { revalidate: 10 } // 秒级缓存</span></span>
<span class="line"><span>);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>export default async function Page() {</span></span>
<span class="line"><span>  const products = await getProducts();</span></span>
<span class="line"><span>  return &lt;ProductList data={products} /&gt;;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>❗避坑提示：</p><table><thead><tr><th><strong>避坑点</strong></th><th><strong>建议</strong></th></tr></thead><tbody><tr><td>unstable_cache 不能包裹组件</td><td>只能包裹纯函数</td></tr><tr><td>key 相同则共用缓存</td><td>注意动态参数作为 key</td></tr><tr><td>和 revalidate 配合使用时，以更短周期为主</td><td>优先考虑函数级缓存提升性能</td></tr></tbody></table><hr><h2 id="🔬-实战对比总结" tabindex="-1"><a class="header-anchor" href="#🔬-实战对比总结"><span><strong>🔬</strong>** 实战对比总结**</span></a></h2><table><thead><tr><th><strong>场景</strong></th><th><strong>推荐使用</strong></th></tr></thead><tbody><tr><td>缓存整页静态内容（如资讯页）</td><td>revalidate</td></tr><tr><td>缓存某个数据库查询结果</td><td>unstable_cache</td></tr><tr><td>多页面复用同一个数据</td><td>unstable_cache（可跨组件）</td></tr><tr><td>无需缓存（实时数据）</td><td>SSR/ISR，不加缓存配置</td></tr></tbody></table><hr><h2 id="🧠-延伸思考-什么时候两者一起用" tabindex="-1"><a class="header-anchor" href="#🧠-延伸思考-什么时候两者一起用"><span><strong>🧠</strong>** 延伸思考：什么时候两者一起用？**</span></a></h2><p>在以下场景中，可组合使用：</p><div class="language-plain line-numbers-mode" data-highlighter="shiki" data-ext="plain" data-title="plain" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>export const revalidate = 300; // 整页缓存 5 分钟</span></span>
<span class="line"><span></span></span>
<span class="line"><span>const getStock = unstable_cache(fetchStock, [&#39;stock&#39;], { revalidate: 60 }); // 每分钟刷新库存</span></span>
<span class="line"><span></span></span>
<span class="line"><span>export default async function Page() {</span></span>
<span class="line"><span>  const stock = await getStock();</span></span>
<span class="line"><span>  return &lt;div&gt;当前库存：{stock}&lt;/div&gt;;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>🎯效果：</p><ul><li>页面每 5 分钟重新构建</li><li>但库存数据每分钟更新，避免缓存陈旧</li></ul><hr><h2 id="✅-总结一句话" tabindex="-1"><a class="header-anchor" href="#✅-总结一句话"><span><strong>✅</strong>** 总结一句话：**</span></a></h2>`,28);function h(u,v){const a=l("font");return d(),r("div",null,[p,s(a,{style:{color:"#0e0e0e"}},{default:t(()=>[e("在电商首页中，某个数据（如 banner 或库存）每 10 秒更新一次，用 ")]),_:1}),s(a,{style:{color:"#0e0e0e"}},{default:t(()=>[e("unstable_cache(fn, [key], { revalidate: 10 })")]),_:1}),s(a,{style:{color:"#0e0e0e"}},{default:t(()=>[e(" 包裹 fetch，避免重复 DB 读取")]),_:1}),o,s(a,{style:{color:"#0e0e0e"}},{default:t(()=>[e("revalidate 控页面缓存时间，unstable_cache 控函数缓存时间，")]),_:1}),e("**"),s(a,{style:{color:"#0e0e0e"}},{default:t(()=>[e("两者组合使用可实现多层缓存优化")]),_:1}),e("**")])}const m=i(c,[["render",h],["__file","🚀 Next.js 缓存机制解析unstable_cache vs revalidate.html.vue"]]),_=JSON.parse('{"path":"/businessProblem/%E8%BF%9B%E9%98%B6/%F0%9F%9A%80%20Next.js%20%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90unstable_cache%20vs%20revalidate.html","title":"Next.js 缓存机制解析：unstable_cache vs revalidate","lang":"zh-CN","frontmatter":{"title":"Next.js 缓存机制解析：unstable_cache vs revalidate","icon":"circle-info","description":"1️⃣** 本质透视镜：是什么？** 本质是：Next.js 中两种不同层级的缓存控制机制，分别用于 → unstable_cache: 函数级缓存 → revalidate: 路由级 ISR 缓存控制 这其实就是：执行层 vs 构建层的缓存粒度控制工具。 2️⃣** 关系拓扑图：为什么存在？** revalidate: 控制 页面级生成的 HTML/...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/businessProblem/%E8%BF%9B%E9%98%B6/%F0%9F%9A%80%20Next.js%20%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90unstable_cache%20vs%20revalidate.html"}],["meta",{"property":"og:site_name","content":"前端知识随笔"}],["meta",{"property":"og:title","content":"Next.js 缓存机制解析：unstable_cache vs revalidate"}],["meta",{"property":"og:description","content":"1️⃣** 本质透视镜：是什么？** 本质是：Next.js 中两种不同层级的缓存控制机制，分别用于 → unstable_cache: 函数级缓存 → revalidate: 路由级 ISR 缓存控制 这其实就是：执行层 vs 构建层的缓存粒度控制工具。 2️⃣** 关系拓扑图：为什么存在？** revalidate: 控制 页面级生成的 HTML/..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-07-28T13:02:59.000Z"}],["meta",{"property":"article:author","content":"小安"}],["meta",{"property":"article:modified_time","content":"2025-07-28T13:02:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Next.js 缓存机制解析：unstable_cache vs revalidate\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2025-07-28T13:02:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小安\\",\\"url\\":\\"https://github.com/an31742\\"}]}"]]},"headers":[{"level":2,"title":"1️⃣** 本质透视镜：是什么？**","slug":"_1️⃣-本质透视镜-是什么","link":"#_1️⃣-本质透视镜-是什么","children":[]},{"level":2,"title":"2️⃣** 关系拓扑图：为什么存在？**","slug":"_2️⃣-关系拓扑图-为什么存在","link":"#_2️⃣-关系拓扑图-为什么存在","children":[{"level":3,"title":"⚠️** 关键区别：**","slug":"⚠️-关键区别","link":"#⚠️-关键区别","children":[]}]},{"level":2,"title":"3️⃣** 行动意义锚点：为什么要用？**","slug":"_3️⃣-行动意义锚点-为什么要用","link":"#_3️⃣-行动意义锚点-为什么要用","children":[]},{"level":2,"title":"4️⃣** 步骤拆解器：怎么做？**","slug":"_4️⃣-步骤拆解器-怎么做","link":"#_4️⃣-步骤拆解器-怎么做","children":[{"level":3,"title":"✅** revalidate实战（路由级缓存）**","slug":"✅-revalidate实战-路由级缓存","link":"#✅-revalidate实战-路由级缓存","children":[]},{"level":3,"title":"✅** unstable_cache 实战（函数级缓存）**","slug":"✅-unstable-cache-实战-函数级缓存","link":"#✅-unstable-cache-实战-函数级缓存","children":[]}]},{"level":2,"title":"🔬** 实战对比总结**","slug":"🔬-实战对比总结","link":"#🔬-实战对比总结","children":[]},{"level":2,"title":"🧠** 延伸思考：什么时候两者一起用？**","slug":"🧠-延伸思考-什么时候两者一起用","link":"#🧠-延伸思考-什么时候两者一起用","children":[]},{"level":2,"title":"✅** 总结一句话：**","slug":"✅-总结一句话","link":"#✅-总结一句话","children":[]}],"git":{"createdTime":1753707779000,"updatedTime":1753707779000,"contributors":[{"name":"an31742","email":"2234170284@qq.com","commits":1}]},"readingTime":{"minutes":2.9,"words":871},"filePathRelative":"businessProblem/进阶/🚀 Next.js 缓存机制解析unstable_cache vs revalidate.md","localizedDate":"2025年7月28日","autoDesc":true}');export{m as comp,_ as data};
