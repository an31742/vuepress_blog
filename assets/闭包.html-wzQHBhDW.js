import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,o as n,a}from"./app-D1s-CSjg.js";const l={},e=a(`<h2 id="什么是作用域-什么是作用域链" tabindex="-1"><a class="header-anchor" href="#什么是作用域-什么是作用域链"><span>什么是作用域，什么是作用域链</span></a></h2><p>作用域：变量起作用的范围</p><ul><li>js中只有两种：全局作用域  局部作用域</li><li></li></ul><p>1.全局作用域：变量在任何地方起作用</p><ul><li>全局变量:在函数外面声明</li></ul><p>2.局部作用域：变量只能在函数内部起作用 局部变量：在函数内部声明</p><ul><li>1.作用域链是怎么来的 <ul><li>默认情况下，我们的js代码处于全局作用域，当我们声明一个函数时，此时函数体会开辟一个局部作用域， 如果我们在这个函数体中又声明一个函数，那么又会开辟一个新的局部作用域，以此类推，就会形成一个作用域链</li></ul></li><li>2.变量在作用域链上的访问规则 <ul><li>就近原则：访问变量时，会优先访问的是在自己作用域链上声明的变量，如果自己作用域链上没有声明这个变量，那么就往上一级去找有没有声明这个变量，如果有就访问，如果没有就继续往上找有没有声明，直到找到0级作用域链上，如果有，就访问，如果没有就报错</li></ul></li></ul><h2 id="什么是闭包-闭包都有哪些特性" tabindex="-1"><a class="header-anchor" href="#什么是闭包-闭包都有哪些特性"><span>什么是闭包，闭包都有哪些特性</span></a></h2><ul><li>定义：外部可以调用函数内部的函数，闭包包的是变量</li><li>原因：为什么要包起来？实现变量名的私有化，在外界需要的时候又可以访问改变。</li><li>缺点：闭包的数据常驻内存，不清除的话，会使内存溢出 父函数嵌套子函数，子函数内部引用了父函数的变量，引用的这些变量集合称之为闭包 闭包的特性：</li></ul><ol><li>函数嵌套函数</li><li>函数内部可以引用外部的参数和变量</li><li>参数和变量不会被垃圾回收机制回收</li></ol><p>闭包的优点：</p><p>可以设计私有的方法和变量</p><p>闭包的数据常驻内存，不清除的话，会使内存溢出 闭包的作用：</p><p>闭包常常用来「间接访问一个变量」。换句话说，「隐藏一个变量」。</p><p>这里面确实有闭包，local 变量和 bar 函数就组成了一个闭包（Closure）。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>function test_fn() {</span></span>
<span class="line"><span>  var _num = 0;</span></span>
<span class="line"><span>  return function() {</span></span>
<span class="line"><span>    _num++;</span></span>
<span class="line"><span>    console.log(_num);</span></span>
<span class="line"><span>  }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>var fn = test_fn();</span></span>
<span class="line"><span>fn();1</span></span>
<span class="line"><span>fn();2</span></span>
<span class="line"><span>fn();3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>fn这个变量相当于接受了一个带有初始化变量的函数，</span></span>
<span class="line"><span>每次执行的时候就把内部的变量进行进行一次计算。</span></span>
<span class="line"><span>下次执行的时候，内部的变量再次被执行。</span></span>
<span class="line"><span>一直会持有内部的变量和状态。</span></span>
<span class="line"><span>这就是闭包。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>1.DOM事件绑定</span></span>
<span class="line"><span>for (var i = 0; i &lt; spans.length; i++) {</span></span>
<span class="line"><span>  spans[i].onmouseover = function(num) {</span></span>
<span class="line"><span>    return function() {</span></span>
<span class="line"><span>      console.log(num);</span></span>
<span class="line"><span>    };</span></span>
<span class="line"><span>  }(i);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>可以看到onmouseover后面这个函数自执行，返回个带有初始化状态变量的函数，</span></span>
<span class="line"><span>也是就是每个函数内部的i，被保存下来。</span></span>
<span class="line"><span></span></span>
<span class="line"><span>2.for()循环里的异步函数</span></span>
<span class="line"><span>for (var i = 0; i &lt; arr.length; i++) {</span></span>
<span class="line"><span>  setTimeout(function(argument) {</span></span>
<span class="line"><span>      console.log(i);</span></span>
<span class="line"><span>    }, 1000);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>for循环里嵌套异步，我们在回调函数内需要拿到的数据进行运算，就需要做一个闭包，才能进行参数初始化的保存。所以要写成：</span></span>
<span class="line"><span>for (var i = 0; i &lt; arr.length; i++) {</span></span>
<span class="line"><span>  (function fn(num) {</span></span>
<span class="line"><span>    setTimeout(function(argument) {</span></span>
<span class="line"><span>      console.log(num);</span></span>
<span class="line"><span>    }, 1000);</span></span>
<span class="line"><span>  })(i);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>写个闭包函数，把数据的状态初始化保证在函数内部。或者用arr.forEach;</span></span>
<span class="line"><span>因为forEach后面的函数就形成一个闭包，就不需要再写闭包了。</span></span>
<span class="line"><span>arr.forEach(function(ele, index) {</span></span>
<span class="line"><span>    setTimeout(function(argument) {</span></span>
<span class="line"><span>      console.log(ele,index);</span></span>
<span class="line"><span>    }, 1000);</span></span>
<span class="line"><span>});</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> local</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> bar</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">    local</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">++</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> local</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> bar</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;"> func</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">func</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//为什么要函数套函数呢</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//是因为需要局部变量，所以才把 local 放在一个函数里，如果不把 local 放在一个函数里，local 就是一个全局变量了，达不到使用闭包的目的——隐藏变量（等会会讲）。</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="闭包经典面试题" tabindex="-1"><a class="header-anchor" href="#闭包经典面试题"><span>闭包经典面试题</span></a></h2><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> create</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">100</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    //  调用使用的a的变量是在开始定义时候</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">      console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> fn</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">()</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">  //使用的变量而不是函数执行的时候</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">200</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">  fn</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">// 100</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-javascript line-numbers-mode" data-highlighter="shiki" data-ext="javascript" data-title="javascript" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">200</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">    fn</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">() </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//而不是函数执行的时候查找上级作用域中的变量200</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#E5C07B;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#56B6C2;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#D19A66;">100</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#C678DD;">  function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> fn</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">    //函数使用变量在函数定义的时候</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E5C07B;">    console</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">)   </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//查找上级作用域中的变量100</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">  </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#61AFEF;"> print</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#24292E;--shiki-dark:#E06C75;">fn</span><span style="--shiki-light:#24292E;--shiki-dark:#ABB2BF;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#7F848E;--shiki-light-font-style:inherit;--shiki-dark-font-style:italic;">//100</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>自由变量的查找是在函数定义的时候进行查找，而不是在函数执行的时候进行查找</strong></p><h2 id="this" tabindex="-1"><a class="header-anchor" href="#this"><span>This</span></a></h2><p><strong>this取什么值是在函数执行的时候而不是在函数定义的时候</strong></p><ul><li>this当做普通函数被调用this指向的是window</li><li>是用call，apply，bind传入什么就绑定什么</li><li>作为对象方法被调用返回对象本身</li><li>class方法调用返回实例本身</li><li>箭头函数上级作用域的this</li></ul><h3 id="fn内置参数fn-caller-arguments-callee和arguments分别是什么" tabindex="-1"><a class="header-anchor" href="#fn内置参数fn-caller-arguments-callee和arguments分别是什么"><span>fn内置参数fn.caller, arguments.callee和arguments分别是什么?</span></a></h3><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#24292e;--shiki-dark:#abb2bf;--shiki-light-bg:#fff;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes github-light one-dark-pro vp-code"><code><span class="line"><span>function parent(param1, param2, param3) {</span></span>
<span class="line"><span>  child(param1, param2, param3);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>function child() {</span></span>
<span class="line"><span>  console.log(arguments); // { &#39;0&#39;: &#39;mqin1&#39;, &#39;1&#39;: &#39;mqin2&#39;, &#39;2&#39;: &#39;mqin3&#39; }</span></span>
<span class="line"><span>  console.log(arguments.callee); // [Function: child] 雇员</span></span>
<span class="line"><span>  console.log(child.caller); // [Function: parent]  雇主</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>parent(&#39;mqin1&#39;, &#39;mqin2&#39;, &#39;mqin3&#39;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,27),p=[e];function t(h,r){return n(),i("div",null,p)}const k=s(l,[["render",t],["__file","闭包.html.vue"]]),v=JSON.parse('{"path":"/frontEndInterview/JavaScript/%E9%97%AD%E5%8C%85.html","title":"闭包","lang":"zh-CN","frontmatter":{"title":"闭包","icon":"circle-info","description":"什么是作用域，什么是作用域链 作用域：变量起作用的范围 js中只有两种：全局作用域 局部作用域 1.全局作用域：变量在任何地方起作用 全局变量:在函数外面声明 2.局部作用域：变量只能在函数内部起作用 局部变量：在函数内部声明 1.作用域链是怎么来的 默认情况下，我们的js代码处于全局作用域，当我们声明一个函数时，此时函数体会开辟一个局部作用域， 如果...","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-docs-demo.netlify.app/frontEndInterview/JavaScript/%E9%97%AD%E5%8C%85.html"}],["meta",{"property":"og:site_name","content":"前端知识随笔"}],["meta",{"property":"og:title","content":"闭包"}],["meta",{"property":"og:description","content":"什么是作用域，什么是作用域链 作用域：变量起作用的范围 js中只有两种：全局作用域 局部作用域 1.全局作用域：变量在任何地方起作用 全局变量:在函数外面声明 2.局部作用域：变量只能在函数内部起作用 局部变量：在函数内部声明 1.作用域链是怎么来的 默认情况下，我们的js代码处于全局作用域，当我们声明一个函数时，此时函数体会开辟一个局部作用域， 如果..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-06-23T10:03:41.000Z"}],["meta",{"property":"article:author","content":"小安"}],["meta",{"property":"article:modified_time","content":"2024-06-23T10:03:41.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"闭包\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-06-23T10:03:41.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"小安\\",\\"url\\":\\"https://github.com/an31742\\"}]}"]]},"headers":[{"level":2,"title":"什么是作用域，什么是作用域链","slug":"什么是作用域-什么是作用域链","link":"#什么是作用域-什么是作用域链","children":[]},{"level":2,"title":"什么是闭包，闭包都有哪些特性","slug":"什么是闭包-闭包都有哪些特性","link":"#什么是闭包-闭包都有哪些特性","children":[]},{"level":2,"title":"闭包经典面试题","slug":"闭包经典面试题","link":"#闭包经典面试题","children":[]},{"level":2,"title":"This","slug":"this","link":"#this","children":[{"level":3,"title":"fn内置参数fn.caller, arguments.callee和arguments分别是什么?","slug":"fn内置参数fn-caller-arguments-callee和arguments分别是什么","link":"#fn内置参数fn-caller-arguments-callee和arguments分别是什么","children":[]}]}],"git":{"createdTime":1719137021000,"updatedTime":1719137021000,"contributors":[{"name":"an31742","email":"2234170284@qq.com","commits":1}]},"readingTime":{"minutes":4.35,"words":1304},"filePathRelative":"frontEndInterview/JavaScript/闭包.md","localizedDate":"2024年6月23日","autoDesc":true}');export{k as comp,v as data};
